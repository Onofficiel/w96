// Generated by RefProc v1.0a.

/*
 * Windows 96 API typings.
 * Copyright (C) windows96.net 2024.
 * 
 * API golden rules and guidelines:
 *  - Read the JSDoc carefully to know what each item does.
 *  - Read the API examples to get an idea of how to use some APIs effectively.
 *  - If there are errors in this typings document, let us know.
 *  - Refrain from using [internal] functions as they are not meant to be used by the user.
 *  - Do not use [undocumented] functions.
 */

// =============================== [/misc.d.ts] ================================
/**
 * This interface represents a symbol which is external.
 */
interface _ExternalSymbol {
    _external: undefined;
}

/**
 * This interface represents a symbol which is not implemented.
 */
interface _NotImplementedSymbol {
    _notImplemented: undefined;
}

/**
 * This interface represents a symbol which is internal.
 */
interface _InternalSymbol {
    _internal: undefined;
}
// ============================== [/apis/fs.d.ts] ===============================
/**
 * FS Stat object.
 */
interface FSBasicStat {
    /** Whether the item is read only */
    readOnly: boolean;

    /** Item length. */
    length: number;

    /** Item type (0 = file, 1 = ). */
    type: number;
}

/**
 * Base file system interface.
 * 
 * All FS drivers should inherit this object and all functions must be implemented.
 * 
 * Write functions can be left out if this is a read only FS.
 */
interface IFileSystem {
    new (prefix: string);

    /**
     * Whether the file system has resources to be accessed remotely.
     */
    remote: boolean;

    /**
     * The prefix (aka drive letter) for the current file system instance.
     *
     * This is managed by the OS.
     */
    prefix: string;

    /**
     * The volume label.
     */
    volumeLabel: string;

    /**
     * The unique driver name.
     */
    driverName: string;

    /**
     * An array which contains the supported file system features.
     */
    features: [];

    /**
     * Initializes the file system.
     */
    init(): Promise<void>;

    /**
     * Called when the file system is being unmounted.
     */
    uninit(): Promise<void>;

    /**
     * Checks if the specified entity is a file.
     * @param path The path to check for.
     */
    isFile(path: string): Promise<boolean>;

    /**
     * Checks if a file is empty.
     * @param path The path to check for.
     */
    isEmpty(path: string): Promise<boolean>;

    /**
     * Creates a new directory (and subdirectories if they do not exist).
     * @param path The path of the directory to create.
     */
    mkdir(path: string): Promise<boolean>;

    /**
     * Removes a directory and its contents.
     * @param path The path of the directory to remove.
     */
    rmdir(path: string): Promise<boolean>;

    /**
     * Creates a new file.
     * @param path The path of the file to create.
     */
    touch(path: string): Promise<boolean>;

    /**
     * Deletes the specified file.
     * @param path The path of the file to remove.
     */
    rm(path: string): Promise<boolean>;

    /**
     * Returns a list of entities contained in the specified path.
     * @param path The directory path to read.
     */
    readdir(path: string): string[];

    /**
     * Copies a directory to a new destination.
     * @param src The source path to copy from.
     * @param dest The destination path to place copied files.
     */
    cpdir(src: string, dest: string): Promise<boolean>;

    /**
     * Copies a file to a new destination.
     * @param src The source path to copy from.
     * @param dest The destination path to place the copied file.
     */
    cpfile(src: string, dest: string): Promise<boolean>;

    /**
     * Moves a file to a new destination.
     * @param src The source path to move from.
     * @param dest The destination path to place the moved file.
     */
    mvfile(src: string, dest: string): Promise<boolean>;

    /**
     * Moves a directory to a new destination.
     * @param src The source path to move from.
     * @param dest The destination path to place moved files.
     */
    mvdir(src: string, dest: string): Promise<boolean>;

    /**
     * Checks if an entity exists.
     * @param path The path to check for.
     */
    exists(path: string): boolean;

    /**
     * Retrieves information about a file system entry.
     * @param path The path to retrieve information for.
     */
    stat(path: string): Promise<FSBasicStat>;

    /**
     * Reads the specified file as a string.
     * @param path The path of the file to read.
     */
    readstr(path: string): Promise<string>;

    /**
     * Reads the specified file as binary.
     * @param path The path of the file to read.
     */
    readbin(path: string): Promise<Uint8Array>;

    /**
     * Returns the file type of a node. This can be a binary or text file.
     * @param path The path to check for.
     * @returns A number representing the file type.
     */
    filetype(path: string): 1 | 0 | -1;

    /**
     * Truncates and writes a UTF-8 encoded string to the specified file.
     * @param path The path of the file to write to.
     * @param data The string to write.
     */
    writestr(path: string, data: string): Promise<boolean>;

    /**
     * Truncates and writes data to the specified file.
     * @param path The path of the file to write to.
     * @param data The data to write.
     */
    writebin(path: string, data: number[] | Uint8Array): Promise<boolean>;
}

/**
 * Indexed File System driver.
 * 
 * Can be inherited for custom implementations.
 * Used by Windows 96 to map as `c:/`
 */
interface IndexedFileSystem extends IFileSystem {
    _fileTable: {
        "/": {
            length: Number,
            dateAccessed: Number,
            dateModified: Number,
            dateCreated: Number,
            readOnly: Boolean,
            type: Number,
            recordId: String
        }
    }

    _fsSort: boolean;
    driverName: "idbfs";

    /**
     * Retrieves a value from the specified IDB key.
     * @param _k The key to retrieve.
     */
    _getItem(_k: String): Promise<Uint8Array>;

    /**
     * Sets a key value in IDB.
     * @param k The key to use.
     * @param v The value to set. 
     */
    _setItem(k: String, v: any): void;

    /**
     * Pushes a file table record.
     * @param path The path of the entity to push.
     * @param size The entity size.
     * @param type The entity type.
     * @param readOnly Whether the entity is read only.
     */
    _pushFtableRecord(path: String, size: Number, type: Number, readOnly: Boolean): void;

    /**
     * Check if an entity exists in the file table.
     * @param path The path to check for.
     */
    _fTableExists(path: string): Boolean;

    /**
     * Pauses IDB sync.
     * @deprecated
     */
    _pauseSync(): void;

    /**
     * Resumes IDB sync.
     * @deprecated
     */
    _resumeSync(): void;

    /**
     * Syncs the file table to IDB.
     */
    _sync(): Promise<void>;

    /**
     * [undocumented function] unsafe mkdir.
     */
    _intmkf(): Promise<boolean>;
}

/**
 * File system class utilizing ram as storage area.
 * 
 * RamFS has the same feature set as the IndexedFileSystem with the sole exception of having an in-memory store instead.
 */
interface RamFileSystem extends IndexedFileSystem {
    /** In-memory data store. */
    store: object;
}

/**
 * File system utilizing local storage as a storage backing.
 * 
 * LocalStorageFS has the same feature set as the IndexedFileSystem, with the exception that all writes are synchronous and blocking, due to the use of localStorage.
 * Base64 has been used to represent binary data, as binary strings are not properly encoded/decoded with the default TextEncoder/TextDecoder API.
 */
interface LocalStorageFileSystem extends IndexedFileSystem {
    /** `Storage` backing store. */
    store: DummyStorageImpl;
}

/**
 * Read only (remote) file system driver.
 * 
 * This file system uses a JSON schema to show its listing.
 * 
 * Used by W:/ (the true system drive).
 */
interface RemoteReadOnlyFileSystem extends IFileSystem {
    new(prefix: String, schemaPath: String);

    fileTable: {
        "/": {
            length: Number,
            type: Number
        }
    };

    readOnly: true;
    remote: true;

    /** The schema path of the remote FS. */
    schemaPath: String;

    /** Origin. */
    origin: String;
}

/**
 * A read-only file system view for ZIP files.
 */
interface ZipReadOnlyFileSystem extends IFileSystem {
    /**
     * Creates a new instance of the ZipReadOnlyFileSystem FS class.
     * @param prefix The prefix to use (e.g. c:)
     * @param archive The archive data.
     */
    new(prefix: string, archive: Uint8Array): ZipReadOnlyFileSystem;

    /** JSZip object */
    archive: any;

    /** Archive data. */
    archiveData: Uint8Array;
}

/**
 * Represents a SysROM FS Item.
*/
interface SysROMFSItem {
    /** Item length. */
    l: number;

    /** Item name. */
    n: string;
}

/**
 * Very basic ROM file system utilizing LocalStorage.
 * 
 * Directories are not supported.
 */
interface SysROMFileSystem extends IFileSystem {
    /** Data prefix. */
    kPrefix: string;

    /**
     * Returns the file map.
     * @returns The file map.
     */
    getFileMap(): SysROMFSItem[];
}

/**
 * [dummy] Local storage object.
 */
interface DummyStorageImpl {
    new(data: Array<any>);
    
    /**
     * Returns an item value.
     * @param {String} key The key to resolve the value for.
     */
    getItem(key: String): String;

    /**
     * Sets a key value.
     * @param {String} key The key to set the value for.
     * @param {String} value The value to set.
     */
    setItem(key: String, value: any): void;

    /**
     * Removes an item.
     * @param {String} key The item key.
     */
    removeItem(key: String): void;

    /**
     * Clears all items.
     */
    clear(): void;
}

/**
 * FS scan mode result object.
 */
interface FSScanModeResult {
    /** FS Item path. */
    path: string;

    /** The file type. */
    filetype: number;
}

/**
 * File caching options.
 */
interface FileCachingOptions {
    /**
     * Content type
     */
    type: "string" | "binary" | "blob",

    /**
     * Whether to overwrite a cached item if it is already cached.
     */
    overwrite: Boolean
}

/**
 * Represents an FS assert structure.
 */
interface FSAssertStruct {
    /** The item path. */
    path: string,

    /** The item type. */
    type?: "dir"|"file",
    
    /** The length of the item. */
    length?: Number
}

/**
 * The Windows 96 file system API.
 */
interface FS {
    /**
     * Mounts a file system using the specified object ("driver").
     * @param fso The file system object to mount.
     * @param forcePrefix Whether a forced prefix (rather than the prefixed defined in the FSO) should be used.
     * @param ignoreTypeCheck Whether to check if FSO is an instance of IFileSystem
     */
    mount(fso: IFileSystem, forcePrefix?: string, ignoreTypeCheck?: boolean): Promise<void>;

    /**
     * Unmounts a file system instance.
     * @param prefix The prefix of the file system instance to unmount.
     */
    umount(prefix: string): Promise<void>;

    /**
     * Gets all mounted file system objects.
     * @returns The file system objects.
     */
    mounts(): IFileSystem[];

    /**
     * Gets all mounted file system prefixes.
     */
    list(): string[];

    /**
     * Get the next available drive letter.
     * @returns The next available letter or null if nothing was found.
     */
    nextLetter(): string | null;

    /**
     * Constructs a blob from the specified file.
     * @param path The path of the file to construct a blob from.
     */
    toBlob(path: string): Promise<Blob>;

    /**
     * Retuns a file system object (FSO) by its prefix.
     * @param prefix The prefix of the FSO to query.
     * @returns The file system object.
     */
    get(prefix: string): IFileSystem;

    /**
     * [ Internal function - use is discouraged. ]
     * Invokes a function on a class implementing IFileSystem.
     * @param path A reference path to use for thrown error objects.
     * @param prefix The prefix of the file system to use.
     * @param func_name The function to invoke.
     */
    _invokeFsFunc(path: string, prefix: string, func_name: string) : any;

    /**
     * Returns the URL for a path.
     * @param path The path to retrieve an URL for.
     */
    toURL(path: string): Promise<string>;

    /**
     * Checks if the specified entity is a file.
     * @param path The path to check for.
     */
    isFile(path: string): Promise<boolean>;

    /**
     * Checks if a file is empty.
     * @param path The path to check for.
     */
    isEmpty(path: string): Promise<boolean>;

    /**
     * Creates a new directory (and subdirectories if they do not exist).
     * @param path The path of the directory to create.
     */
    mkdir(path: string): Promise<boolean>;

    /**
     * Removes a directory and its contents.
     * @param path The path of the directory to remove.
     */
    rmdir(path: string): Promise<boolean>;

    /**
     * Creates a new file.
     * @param path The path of the file to create.
     */
    touch(path: string): Promise<boolean>;

    /**
     * Deletes the specified file.
     * @param path The path of the file to remove.
     */
    rm(path: string): Promise<boolean>;

    /**
     * Returns a list of entities contained in the specified path.
     * @param path The directory path to read.
     * @param scan Whether to retrieve files in scan mode.
     */
    readdir(path: string, scan?: boolean): Promise<string[]|FSScanModeResult[]>;

    /**
     * Copies a directory to a new destination.
     * @param src The source path to copy from.
     * @param dest The destination path to place copied files.
     */
    cpdir(src: string, dest: string): Promise<boolean>;

    /**
     * Copies a file to a new destination.
     * @param src The source path to copy from.
     * @param dest The destination path to place the copied file.
     */
    cpfile(src: string, dest: string): Promise<boolean>;

    /**
     * Moves a file to a new destination.
     * @param src The source path to move from.
     * @param dest The destination path to place the moved file.
     */
    mvfile(src: string, dest: string): Promise<boolean>;
    
    /**
     * Moves a directory to a new destination.
     * @param src The source path to move from.
     * @param dest The destination path to place moved files.
     */
    mvdir(src: string, dest: string): Promise<boolean>;

    /**
     * Checks if an entity exists.
     * @param path The path to check for.
     */
    exists(path: string): Promise<boolean>;

    /**
     * Reads the specified file as a string.
     * @param path The path of the file to read.
     * @returns The text of the file.
     */
    readstr(path: string): Promise<string>;

    /**
     * Reads the specified file as binary.
     * @param path The path of the file to read.
     * @return File contents as byte array.
     */
    readbin(path: string): Promise<Uint8Array>;

    /**
     * Returns the file type of a node. This can be a binary or text file.
     * @param path The path to check for.
     * @returns A number representing the file type.
     */
    filetype(path: string): Promise<1|0|-1>;

    /**
     * Truncates and writes a UTF-8 encoded string to the specified file.
     * @param path The path of the file to write to.
     * @param  data The string to write.
     */
    writestr(path: string, data: string): Promise<boolean>;

    /**
     * Truncates and writes data to the specified file.
     * @param path The path of the file to write to.
     * @param data The data to write.
     */
    writebin(path: string, data: number[] | Uint8Array): Promise<boolean>;

    /**
     * Walks through the contents of a directory.
     * @param path The path to walk.
     */
    walk(path: string): Promise<string[]>;

    /**
     * Retrieves information about a file system entry.
     * @param path The path to retrieve information for.
     */
    stat(path: string): Promise<FSBasicStat>;

    /**
     * Renames a file or folder.
     * @param path The path to rename.
     * @param newName The new name of the directory/file to use.
     */
    rename(path: string, newName: string): Promise<boolean>;

    /**
     * Reads a part of a file.
     * @param path The path to read from.
     * @param offset The starting offset.
     * @param length The length of data to read.
     */
    readBinChunk(path: string, offset: number, length: number): Promise<Uint8Array>;

    /**
     * Reads a part of a file as string.
     * @param path The path to read from.
     * @param offset The starting offset.
     * @param length The length of data to read.
     */
    readStrChunk(path: string, offset: number, length: number): Promise<string>;

    /**
     * Caches a file. Note that this does not track FS changes.
     * @param path The path of the file to cache.
     * @param opts The options to use.
    */
    cache(path: string, opts: FileCachingOptions): Promise<void>;

    /**
     * Uncaches a file.
     * @param path The path of the file to uncache.
     */
    uncache(path: string): void;

    /**
     * Returns a file from cache.
     * @returns {string|Uint8Array|Blob}
     */
    getFromCache(path: string): string | Uint8Array | Blob;

    /**
     * Hashes a file.
     * @param path The path of the file to hash.
     * @param algo The algorithm to use.
     */
    hash(path: string, algo?: "default"|"md5"|"sha256"|"sha384"|"sha512"): Promise<string>;
    
    /**
     * Checks if the required FS structure is present.
     * @param structIn The structure to check for.
     */
    assert(structIn: FSAssertStruct[] | string): Promise<void>;
}

/**
 * FS utilities API.
 */
interface FSUtil {
    /**
     * Returns the parent path of a path.
     * @param path The path to resolve for.
     */
    getParentPath(path: string): string;

    /**
     * Returns the file name of a path.
     * @param path The path to return the filename for.
     */
    fname(path: string): string;

    /**
     * Resolves a path.
     * @param basePath The base path.
     * @param path The path to resolve.
     */
    resolvePath(basePath: string, path: string): string;

    /**
     * Extracts the prefix and path from a path string.
     * @param _fp The file path to use.
     */
    deconstructFullPath(_fp: string): {
        prefix: string,
        path: string
    }

    /**
     * Returns the file extension of a path.
     * @param path The path to extract the extension of.
     * @param ignoreCase Whether to ignore the extension case.
     */
    getExtension(path: string, ignoreCase?: boolean): string;

    /**
     * Downloads a file to the user hard disk.
     * @param path The path to download.
     */
    downloadFile(path: string): Promise<void>;

    /**
     * Fix drive letter case in path.
     * @param path The path.
     */
    normalizeDriveLetter(path: string): string;

    /**
     * Fixes a path.
     * @param path The path to fix.
     * @returns The fixed path.
     */
    fixPath(path: string): string;

    /**
     * Combines paths.
     * @param rootPath The root path.
     * @param paths The paths to add to it.
     */
    combinePath(rootPath: string, ...paths: string[]): string;
}

/**
 * FS Types namespace.
 */
interface FSType {
    /**
     * Base file system interface.
     * 
     * This is an interface object and should not be used to instantiate an FSO.
     */
    FileSystemBase: {
        new(prefix: String): IFileSystem,
        prototype: IFileSystem
    },

    /**
     * Indexed File System driver.
     * 
     * Can be inherited for custom implementations.
     * Used by Windows 96 to map as `c:/`
     */
    IndexedFileSystem: {
        new(prefix: String): IndexedFileSystem,
        prototype: IndexedFileSystem
    },

    /**
     * Ramdrive file system driver.
     */
    RamFileSystem: {
        new(prefix: String): RamFileSystem,
        prototype: RamFileSystem
    },

    /**
     * Local storage file system driver.
     */
    LocalStorageFileSystem: {
        new(prefix: String): LocalStorageFileSystem,
        prototype: LocalStorageFileSystem
    },

    /**
     * Read only (remote) file system driver.
     * 
     * Used by W:/ (the true system drive).
     */
    RemoteReadOnlyFileSystem: {
        new(prefix: String, schemaPath: String): RemoteReadOnlyFileSystem,
        prototype: RemoteReadOnlyFileSystem
    }

    /**
     * A read-only file system view for ZIP files.
     */
    ZipReadOnlyFileSystem: {
        new(prefix: string, archive: Uint8Array): ZipReadOnlyFileSystem,
        prototype: ZipReadOnlyFileSystem
    }

    /**
     * Very basic ROM file system utilizing LocalStorage.
     * 
     * Directories are not supported.
     */
    SysROMFileSystem: {
        new(prefix: string): SysROMFileSystem,
        prototype: SysROMFileSystem
    }
}
// ============================ [/apis/mutex.d.ts] =============================
/**
 * Mutex API
 */
interface MutexAPI {
    /**
     * Mutex registry.
     * 
     * `w96.mutex.registry[id] = <mtx object>`.
     */
    registry: any;

    /**
     * Creates a new mutex.
     * @param tag An optional tag to specify.
     * @returns A mutex ID.
     */
    create(tag?: any): string;

    /**
     * Releases the specified mutex.
     * @param id The ID of the mutex to release.
     */
    release(id: string): void;

    /**
     * Checks for a lock.
     * @param id The ID of the mutex to check.
     */
    isLocked(id: string): boolean;

    /**
     * Gets a mutex by tag.
     * @param tag The tag to search for.
     * @return The found mutex ID.
     */
    find(tag: string): string;
}
// ============================= [/apis/app.d.ts] ==============================
interface AppRegisterProps {
    /** Target command name (the app name). */
    command: string,

    /** App type */
    type: "terminal"|"gui",

    /** File types to handle. */
    filters?: [],

    /** App metadata. */
    meta?: {
        /** Friendly app name. */
        friendlyName: String,

        /** Icon name. */
        icon: String
    },

    /** App class */
    cls: Object
}

/**
 * Application API.
 */
interface AppAPI {
    /**
    * Registers an app.
    * @param props The parameters to use.
    * 
    * @deprecated Only useful for protected system apps.
    */
    register(props: AppRegisterProps): void;

    /**
     * App class templates.
     */
    templates: {
        WizardBaseApplication: any
    }
}
// ============================ [/apis/wndsys.d.ts] =============================
/**
 * Represents window manager animations.
 */
interface WMAnimations {
    /** Window open animation name */
    windowOpen: string,

    /** Window close animation name. */
    windowClose: string
}

/**
 * Size vector.
 */
interface WMSizeVector {
    height: string;
    width: string;
}

/**
 * [internal] Represents window maximization info.
 */
interface WMMaximizeInfo {
    x: string;
    y: string;
    h: string;
    w: string;
}

/** Window on close event. */
interface OnCloseEvent {
    /** Whether the window closure should be canceled. */
    canceled: boolean;
}

/**
 * Represents window creation parameters.
 * 
 * All parameters are optional and have default settings.
 */
interface WindowParams {
    /** Initial X position */
    initialX: number;

    /** Initial Y position. */
    initialY: number;

    /** Minimum height */
    minHeight: number;

    /** Minimum width */
    minWidth: number;

    /** Initial height */
    initialHeight: number;

    /** Initial width. */
    initialWidth: number;

    /** Window title. */
    title: string;

    /** Whether the window can be resized. */
    resizable: boolean;

    /** Whether the window is draggable. */
    draggable: boolean;

    /** Whether the window should be registered in the taskbar. */
    taskbar: boolean;

    /** The window icon to use. */
    icon?: string;

    /** Whether to center the window on creation. */
    center: boolean;

    /** Window body text */
    body?: string;

    /** The css class to apply to the window body container. */
    bodyClass?: string;

    /** The css class to apply to the window. */
    windowClass?: string;

    /** The control box style to use. */
    controlBoxStyle: "WS_CBX_MINMAXCLOSE"|"WS_CBX_CLOSE"|"WS_CBX_MINCLOSE"|"WS_CBX_NONE";
    
    /** Whether to allow mobile mode to resize this window and make it fullscreen. */
    mobResize: boolean;

    /**
     * Whether to apply the iframe fix.
     * 
     * This fix makes the window clickable when its inactive. Otherwise, an iframe captures your pointer events.
     * 
     * The side effect is that this fix blocks iframe pointer events until the window is active again.
     * */
    iframeFix: boolean;

    /**
     * Whether to disable the window compositor for the specified window.
     * */
    noCompose: boolean;

    /** Whether to ignore focus events. */
    ignoreFocus: boolean;

    /** The ZLayer to use. */
    zLayer: "NORMAL"|"LOW"|"HIGH";

    /** [internal] For developers only. */
    disableCommentsBtn: boolean;

    /** Window animation preferences. */
    animations: WMAnimations;

    /** The window container to use. */
    wndContainer?: HTMLElement;
}

/**
 * Represents a window object.
 */
interface StandardWindow {
    /**
     * [internal] Creates a new window with the specified parameters.
     * 
     * This should not be used in user applications.
     */
    new(params: WindowParams): StandardWindow;

    /** The window ID. */
    id: string;

    /** Whether the window uses an icon. */
    useIcon: boolean;

    /** The underlying HTML element for this window. */
    wndObject: HTMLDivElement;

    /** The window animations to use. */
    animations: WMAnimations;

    /** A copy of the creation parameters. */
    params: WindowParams;

    /** Whether this window is registered. */
    isRegistered: boolean;

    /** Whether this window is registered on the app bar (taskbar) */
    appbarRegistered: boolean;

    /** Whether the window is shown. */
    shown: boolean;

    /** [internal] Do not use. */
    _wmStylingAllowed: boolean;

    /** [internal] Do not use. */
    _waitResolveFn: boolean;

    /** Whether this window is maximized. */
    maximized: boolean;

    /** Whether this window is minimized. */
    minimized: boolean;

    /** Whether the UI is being updated. */
    uiUpdating: boolean;

    /** The window icon URL. */
    windowIcon?: string;

    /** The window title. */
    title: string;

    /** Window maximization info. */
    maximizeInfo: WMMaximizeInfo;

    /** [internal] Do not use. */
    ownerWindow: null;

    /** [internal] Do not use. */
    _ownerProps: null;

    /** [internal] Do not use. */
    _childWindowDlg: null;

    // --- Events ---

    /**
     * Called on window closure.
     * @param e On close event parameters.
     */
    onclose?: (e: OnCloseEvent)=>void;

    /** Called when the window is activated. */
    onactivate?: ()=>void;

    /** Called when the window is deactivated. */
    ondeactivate?: ()=>void;
    
    /** [internal] Do not use. */
    onfinalclose?: ()=>void;

    /** [internal] Do not use. */
    onload?: ()=>void;

    /** [internal] Do not use. */
    ondarkenelements?: ()=>void;

    /** [internal] Do not use. */
    onlightenelements?: ()=>void;

    /** Called when the window is shown. */
    onshown?: ()=>void;

    /** Called when the window is resized. */
    onresize?: ()=>void;

    /** Called when the window is moved. */
    onmove?: ()=>void;

    /** Called when the window is minimized. */
    onminimize?: ()=>void;

    // --- Extensions ---
    /** [internal] Window extensions, do not use. */
    _ext: {
        /** Window snap parameters */
        windowSnap: {
            snapped: boolean;
            originalSize: WMSizeVector;
            snappedSize: WMSizeVector;
        }
    }

    /**
     * Waits for window closure.
     */
    wait(): Promise<void>;

    /**
     * [internal]
     * Sets the owner for this window.
     * @param wnd The window to set as owner.
     * @deprecated
     */
    setOwner(wnd: StandardWindow, opts: any): void;

    /**
     * Shows the titlebar menu
     * @param e The mouse event
     */
    showTitlebarMenu(e: MouseEvent): void;

    /**
     * Registers the Window in the window system and creates appbar elements, etc.
     */
    registerWindow(): void;

    /**
     * Registers the application bar for this window.
     */
    registerAppBar(): void;

    /**
     * Sets the title of the window.
     * @param text The text to use as title.
     */
    setTitle(text: string): void;

    /**
     * Sets the window HTML contents.
     * @param text The HTML text to use.
     */
    setHtml(text: string): void;

    /**
     * Randomizes the window position.
     */
    randomizePosition(): void;

    /**
     * Set the window starting position
     * @param noMax If the window should continue past a threshold or not
     */
    setStartPos(noMax?: boolean): void;

    /**
     * Shows the window.
     */
    show(): void;

    /**
     * Centers the window.
     */
    center(current?: boolean): void;

    /**
     * Activates the window.
     */
    activate(): void;

    /**
     * Sets the window visibility.
     * @param visibility Should the window be visible?
     */
    setVisible(visibility: boolean): void;

    /**
     * Returns whether this window is active.
     */
    isActive(): void;

    /**
     * Minimizes the window.
     * @param skipAnimation Disable bounceIn animation.
     */
    toggleMinimize(skipAnimation?: boolean): void;

    /**
     * Toggles whether the window is maximized or not.
     */
    toggleMaximize(): void;

    /**
     * Closes the window.
     * @param ignoreEvents Whether to ignore closing events.
     */
    close(ignoreEvents?: boolean): void;

    /**
     * [internal] Called when the window close
     * animation is finished.
     */
    _onCloseEnd(): void;

    /**
     * [internal] Do not use.
     */
    _destroy(): void;

    /**
     * Darkens all UI elements when a window is about to be deactivated.
     */
    darkenElements(): void;

    /**
     * Does the reverse of `darkenElements()`.
     */
    lightenElements(): void;

    /**
     * Sets the window icon to the specified URL.
     * @param iconUrl The URL of the icon to use.
     */
    setWindowIcon(iconUrl: string): HTMLElement|false;

    /**
     * Sets the control box style for this window.
     * 
     * This also respects the Aero-like setting of disabling buttons rather than removing them.
     * @param cbstyle Control box style.
     */
    setControlBoxStyle(cbstyle: "WS_CBX_CLOSE"|"WS_CBX_MINCLOSE"|"WS_CBX_MINMAXCLOSE"|"WS_CBX_NONE"): void;

    /**
     * Sets a new window size.
     * @param w The new width of the window.
     * @param h The new height of the window.
     */
    setSize(w: number, h: number, ignoreThemeOffsets?: boolean): void;

    /**
     * Sets the position of a window.
     * @param x The x coordinate to use.
     * @param y The y coordinate to use.
     */
    setPosition(x: number, y: number): void;

    /**
     * Return window bounds.
     */
    getBounds(): DOMRect;

    /**
     * Get computed window bounds.
     * @deprecated - getBounds() is the default now.
     */
    getComputedBounds(): DOMRect;

    /**
     * Returns the HTML container.
     */
    getBodyContainer(): HTMLDivElement;
}

/**
 * Represents the window manager configuration.
 */
interface WMConfig {
    /**
     * Dragging behavior configuration.
     */
    dragging: {
        /** Whether to hide the window whilst dragging. */
        hideWindow: false,

        /** Whether to use a simple drag box when dragging. */
        simpleDragBox: false
    },

    /** WM features. */
    features: {
        /** Whether window snap is enabled. */
        windowSnap: true,

        /** Whether to disable all animations. */
        disableAllAnimations: false,

        /** Whether to enable the clearfix hack (to fix bitmap font issues). */
        enableClearFix: false,

        /** Whether to use 12 hr time. */
        use12hTime: false
    },
    /**
     * WM animations.
     */
    animations: {
        /** Window open animation. */
        windowOpen: string,

        /** Window close animation. */
        windowClose: string
    }
}

/**
 * Windows 96 Window System API.
 */
interface WindowSystem {
    /**
     * Deactivates all windows.
     */
    deactivateAllWindows(): void;

    /**
     * Sets the window container to use.
     * @param {HTMLDivElement} element The element to use as window container.
     */
    setWindowContainer(element: HTMLDivElement): void;

    /**
     * Finds a window object with the specified id.
     * @param {String} id The id of the window to find.
     * @returns {StandardWindow} The window.
     */
    findWindow(id: String): StandardWindow;

    /**
     * Closes all windows.
     * 
     * @param ignoreEvents Whether to ignore window closure events.
     */
    closeAllWindows(ignoreEvents?: boolean): void;

    /**
     * Gets the currently active window.
     */
    getActiveWindow(): StandardWindow | undefined;

    /**
     * Destroys the drag handler of the specified window.
     */
    destroyDragHandler(wnd: StandardWindow): void;

    /**
     * Makes a window draggable.
     * @param wnd The window to make draggable.
     */
    createDragHandler(wnd: StandardWindow): void;
    
    /**
     * Makes a window resizable.
     * @param wnd The window to make resizable.
     */
    createResizeHandler(wnd: StandardWindow): void;

    /**
     * Destroys the resize handler.
     * @param wnd The window to destroy the resize handler for.
     */
    destroyResizeHandler: (wnd: StandardWindow)=>void;

    /**
     * Gets the container which contains all HTML windows.
     */
    getWindowContainer: ()=>HTMLElement | HTMLDivElement;

    /**
     * Set whether to disable app bar (taskbar) registration.
     * @param value Whether to disable the app bar.
     */
    disableAppBar: (value: boolean)=>boolean;

    /**
     * Sets the window Manager configuration.
     */
    setConfig(config: WMConfig): Promise<void>;

    /**
     * Returns the WM config.
     */
    getConfig(): WMConfig;

    /**
     * Starting Z index for window creation.
     */
    startZIndex: Number;

    /**
     * Window registry.
     */
    windows: StandardWindow[];
}
// ============================ [/apis/ui/ui.d.ts] =============================

/**
 * Represents an ECSS variable.
 */
interface ECSSVar {
    /** Var ID. */
    id: string;

    /** Value. */
    value: string;
}

/**
 * ECSS processing context.
 */
interface ECSSPCtx {
    /** ECSS Variables */
    vars: ECSSVar[];
}

/**
 * Extended CSS processor.
 * 
 * Right now, just a simple preprocessor.
 */
interface ECSSAPI {
    /**
     * Processes an extended css file.
     * @param textIn Input text.
     * @param pCtx Processing context.
     * @returns Preprocessed CSS text.
     */
    process(textIn: string, pCtx?: ECSSPCtx): string;
}

/** Window compositor API. */
interface WinCompAPI {
    /**
     * Enable optional window compositing.
     * @param v Whether to enable it.
     */
    enable(v: boolean): void;

    /**
     * Calls the compositor.
     * @param wnd The window to call the compositing functions for.
     */
    callComposite(wnd: StandardWindow): void;

    /**
     * Compositor events.
     */
    events: EventEmitter;
}

/**
 * Represents a mapped blob resource.
 */
interface TMappedBlobResource {
    /** Identifier */
    id: string;

    /** Value */
    value: string;
}

/**
 * Represents theming UI variables.
 */
interface ThemeUIVars {
    /** CSS padding to add to titlebar icon. */
    titlebarIconPadding: string;

    /** Max window width formula */
    maxWindowSizeFormulaW: string;
    
    /** Max window height formula. */
    maxWindowSizeFormulaH: string;

    /** Defaults. */
    defaults: {
        /** Message box defaults */
        mbox: {
            w: number;
            h: number;
        }
    };

    /** Window creation vars */
    windowCreationProps: {
        paddingW: number;
        paddingH: number;
        snapPaddingW: number;
        snapPaddingH: number;
    };


    tbOffsetH: number;
    tbOffsetW: number;

    /** Taskbar (app bar) height. */
    taskbarHeight: number;

    /** The superbar represents a taskbar with 32x32 icons instead of 16x16 */
    superbarEnabled: boolean;

    /** Whether the clearfix hacks are enabled. */
    clearFixEnabled: boolean;
}

/**
 * Theming API.
 */
interface ThemeAPI {
    /** Current theme name. */
    currentTheme: string;

    /** [internal] Icon cache. */
    iconCache: any;

    /**
     * Clears the current icon cache.
     */
    clearIconCache(): void;

    /** Theme registry. */
    registeredThemes: any;

    /** Gets the active theme variant. */
    getActiveVariant(): string|null;

    /**
     * Returns the icon url for the specified icon.
     * @param name The name of the icon to return a URL from.
     * @param size The size of the icon to return. Default is `32x32`.
     * @param format The format of the icon to use.
     */
    getIconUrl(name: string, size?: string, format?: string): Promise<string|null>;

    /**
     * Returns an icon url for the specified file or directory.
     * @param filePath The path of the file/directory to retrieve an icon for.
     * @param size The size of the icon to retrieve.
     * @param format The format of the icon to retrieve.
     */
    getFileIconUrl(filePath: string, size?: string, format?: string): Promise<string|null>;

    /**
     * Gets an icon for the specified file extension.
     * @param ext The extension to get the icon for.
     * @param size The size of the icon to retrieve.
     * @param format The format of the icon to retrieve.
     */
    getIconFromFileExtension(ext: string, size?: string, format?: string): Promise<string|null>;

    /**
     * Gets mapped blob resources.
     */
    getMappedBlobResources(): TMappedBlobResource[];

    /**
     * Append CSS to system style.
     * @param css The CSS to append.
     */
    cssa(css: string): void;

    /**
     * Loads CSS from a file and appends it to the system style.
     * @param url The URL of the file to load.
     */
    cssl(url: string): void;

    /** Current UI variables. */
    uiVars: ThemeUIVars;

    /**
     * Unload themes and reset everything.
     * @param reloadDesk Whether to reload the desktop.
     */
    unloadTheme(reloadDesk?: boolean): void;

    /** Reloads the desktop. */
    reloadDesktop(): Promise<void>;

    /**
     * Gets a sound from the current theme.
     *
     * @param id The id of the sound to get
     */
    getSound(id: string): Promise<string|undefined>;

    /**
     * Shortcut for new Audio(getSound(id)).play()
     * also handles autoplay errors (if there are any)
     *
     * @param id The id of the sound to play
     */
    playSound(id: string): Promise<void>;

    /**
     * Revoke all sound URLs in the sound cache.
     */
    dropSoundCache(): void;

    /**
     * Loads an icon map.
     * @param path The path of the icon map to load
     */
    loadIconMap(path: string): Promise<void>;

    /**
     * Loads a theme by id.
     * @param id The ID of the theme to load.
     * @param opts Apply options
     */
    applyTheme(id: string, opts?: any): Promise<void>;

    /**
     * Initializes the theming engine.
     *
     * Required for any sort of theming related services.
     * THIS SHOULD NEVER BE INITIALIZED TWICE - THE SYSTEM VALUES ARE DESIGNED TO BE INHERITED.
     *
     * @param isRecovery Is in recovery mode - only use W:/ paths
     */
    init(isRecovery: boolean): Promise<void>;
}

/**
 * Represents a context menu item.
 */
interface ContextMenuItem {
    /**
     * The item type. Can either be `separator`, `normal`, or `submenu`.
     */
    type: "normal"|"separator"|"submenu";

    /**
     * The item label.
     */
    label?: String;

    /**
     * The item icon URL.
     */
    icon?: String;

    /**
     * Fired when the item was clicked.
     */
    onclick?: (e: MouseEvent, tag: string) => void;

    /**
     * Fired when the item was hovered on.
     */
    onhover?: (e: MouseEvent, tag: string) => void;

    tag?: String;

    /** Whether the item is checked. */
    checked?: boolean;

    /** Whether the item is disabled. */
    disabled?: boolean;

    /** Whether to remove icon prespace. */
    removeIconPrespace?: boolean;

    /**
     * Submenu items.
     */
    items?: ContextMenuItem[]
}

/**
 * Represents a context menu object.
 */
interface ContextMenu {
    new(items: ContextMenuItem[]);

    menuCounter: Number;

    /**
     * Renders the menu at the specified position.
     * @param x The X position.
     * @param y The Y position.
     * @param menu [do not use]
     * @param quiet Whether to be quiet.
     */
    renderMenu(x: Number, y: Number, menu?: ContextMenuItem[], quiet?: boolean): HTMLDivElement;
}

/**
 * Represents a MenuBar (a strip with menus containing tasks).
 */
interface MenuBar {
    menuElement: HTMLDivElement;
    _menu: ContextMenu;

    /**
     * Adds a root menu item.
     * @param label The label to use.
     * @param contextMenuItems The menu items to add.
     * @param addMbar Add mbar class.
     */
    addRoot(label: String, contextMenuItems: ContextMenuItem[], addMbar?: boolean): HTMLSpanElement

    /**
     * Returns the menu div.
     * 
     * Use this as the element to append your menu to a HTML container.
     */
    getMenuDiv(): HTMLDivElement;
}

/** DropZone properties. */
interface DropZoneProps {
    data: any;

    /** Accepted data. Array can contain: `file`, `text`. */
    accepts: string[];

    ondrop: (icon: HTMLElement)=>boolean;
}

/**
 * DropZone API.
 */
interface DropZone {
    /**
     * Creates a drop zone for dropping desktop icons.
     * @param el The element to process.
     * @param data The data to put.
     */
    create(el: HTMLElement, data: any): void;

    /**
     * Returns the drop zone for a specific object.
     * @param {HTMLElement} el The element to process.
     */
    get(el: HTMLElement): DropZoneProps;
}

/**
 * Select box start context.
 */
interface SBStartCtx {
    /** The container. */
    container: HTMLElement;

    /** The select box element. */
    box: HTMLElement;
}

/**
 * SelectBoxListener API.
 */
interface SelectBoxListener {
    /**
     * The container to use for the selection box. This will contain the selectable items.
     */
    containerEl: HTMLElement;

    /**
     * Called when a selection has been completed.
     */
    onselectionfinished: ()=>void;

    /**
     * Called on selection start.
     */
    onselectionstart: (ctx: SBStartCtx)=>void;

    /**
     * Detection grid cell size. Lower values will ensure better precision, but will also negatively impact performance. The default is recommended for most cases.
     */
    detectionGridSize: {
        h: number;
        w: number;
    };

    /**
     * Minimum box size to process events further.
     */
    minProcessingSize: {
        h: number,
        w: number
    };

    /**
     * Whether to disable the selection box lister.
     */
    disabled: boolean;

    /**
     * [internal] Whether this selection box listener is initalized.
     * This listener cannot be initialized twice.
     */
    __initialized: boolean;

    /**
     * Inits the select box listener.
     */
    init(): void;

    /**
     * Returns all selected items.
     * @returns The selected items.
     */
    getSelectedItems(): NodeList;

    /**
     * Destroys this listener.
     */
    uninit(): void;
}

/**
 * User interface API.
 */
interface UIAPI {
    /** Extended CSS API. */
    ecss: ECSSAPI;

    /** Window compositor API. */
    comp: WinCompAPI;

    /** Simple MsgBox API. */
    MsgBoxSimple: MsgBoxSimple;

    /** Theming API. */
    Theme: ThemeAPI;

    /**
     * Represents a context menu object.
     */
    ContextMenu: {
        /** Creates a new context menu with the specified items. */
        new(items: ContextMenuItem[]): ContextMenu,
        prototype: ContextMenu;
    };

    /**
     * @deprecated old api - kept for compatibility.
     * 
     * An object representing a message box.
     */
    MessageBox: {
        /**
         * Creates a message box.
         * @param title The title of the message box window.
         * @param message The message of the message box text.
         * @param icon The icon name of the message box icon.
         * @param buttons The buttons to use.
         * @param onclose The callback to call once the message box is closed.
         * @param quiet Whether to be quiet.
         */
        new(title: string, message: string, icon: string, buttons: string, onclose: Function, quiet?: boolean): MessageBox,
        prototype: MessageBox;
    };

    /**
     * Represents a MenuBar (a strip with menus containing tasks).
     */
    MenuBar: {
        new(): MenuBar,
        prototype: MenuBar;
    };

    /**
     * An object representing a dialog to allow the user to select (open) a file.
     */
    OpenFileDialog: {
        /**
         * Creates a file open dialog.
         * @param initialDirectory The initial directory to start in.
         * @param filter The file filter to use.
         * @param callback The callback to call once the dialog completes.
         */
        new(initialDirectory: string, filter: string[], callback: (path: string|null) => void): OpenFileDialog;
        prototype: OpenFileDialog;
    };

    /**
     * An object representing a dialog to allow the user to save a file.
     */
    SaveFileDialog: {
        /**
         * Creates a file save dialog.
         * @param initialDirectory The initial directory to start in.
         * @param filter The file filter to use.
         * @param callback The callback to call once the dialog completes.
         */
        new(initialDirectory: string, filter: string[], callback: (path: string|null) => void): SaveFileDialog;
        prototype: SaveFileDialog;
    };

    /**
     * Represents an operation dialog.
     */
    OperationDialog: {
        new(options?: OperationDialogOptions): OperationDialog,
        prototype: OperationDialog;
    };

    /**
     * Shows an exception window.
     * @param exception The exception to show.
     */
    showExceptionWindow(exception: Error|string): Promise<void>;

    /**
     * DialogCreator API.
     */
    DialogCreator: DialogCreator;

    /**
     * Animates an element.
     * @param element The element to aniamte.
     * @param animationName The name of the animation to use.
     * @param callback The callback to call when the animation is complete.
     */
    animateElement(element: string | HTMLElement, animationName: string, callback: ()=>void): void;
    
    /**
     * DropZone API.
     */
    DropZone: DropZone;

    /**
     * Components namespace.
     */
    components: ComponentsNS;

    /** UI Utilities API */
    util: UIUtilsAPI;
}

// ============================= [/apis/core.d.ts] ==============================
/**
 * An object representing an event emitter queued event.
 */
interface EmitterEvent {
    /**
     * The name of the event.
     */
    name: String;

    /**
     * The event callback.
     */
    callback: Function;

    /**
     * Specifies whether the event should be recurring or single.
     */
    type: "recurring"|"single";
}

/**
 * An object which represents an event queue.
 * 
 * Similar to NodeJS event emitter.
 */
interface EventEmitter {
    eventQueue: EmitterEvent[];

    /**
     * Listens for an event.
     * @param {String} evtName The event name to listen for.
     * @param {Function} callback The callback to assign.
     */
    on(evtName: String, callback: Function): void;

    /**
     * Listens for an event once.
     * @param {String} evtName The event name to listen for.
     * @param {Function} callback The callback to assign.
     */
    once(evtName: String, callback: Function): void;

    /**
     * Fires an event.
     * @param {String} evtName The event name to fire.
     * @param {*} args The arguments to pass.
     */
    emit(evtName: String, ...args: any): void;
}
// ========================== [/apis/ui/commdlg.d.ts] ===========================

/**
 * @deprecated old api - kept for compatibility.
 * 
 * An object representing a message box.
 */
interface MessageBox {
    /**
     * Creates a message box.
     * @param title The title of the message box window.
     * @param message The message of the message box text.
     * @param icon The icon name of the message box icon.
     * @param buttons The buttons to use.
     * @param onclose The callback to call once the message box is closed.
     * @param quiet Whether to be quiet.
     */
    new(title: string, message: string, icon: string, buttons: string, onclose: Function, quiet?: boolean);

    /**
     * Fired when the message box is being closed.
     */
    onclose: Function;

    /**
     * Whether to be quiet.
     */
    quiet: boolean;

    /**
     * The message box icon.
     */
    readonly icon: string;

    /**
     * OK Button.
     */
    readonly btnOk?: HTMLButtonElement;

    /**
     * The underlying window object for the message box.
     */
    dlg: StandardWindow;

    /**
     * Shows the message box.
     */
    show(): void;

    /**
     * Sets the size of the message box.
     * @param w The width of the message box to set.
     * @param h The height of the message box to set.
     */
    setSize(w: number, h: number): MessageBox;

    /**
     * Closes the window.
     */
    closeDialog(): void;
}

/**
 * Simple MsgBox API.
 * 
 * @deprecated Legacy API, retained for compatibility. Consider migrating to `DialogCreator`.
 */
interface MsgBoxSimple {
    /**
     * [old API - use DialogCreator]
     * 
     * Shows a messagebox containing an error.
     * @param title The title of the message box.
     * @param message The message to display.
     * @param oktext The string to display as the confirmation button caption.
     */
    error(title: string, message: string, oktext: string): MessageBox;
    
    /**
     * [old API - use DialogCreator]
     * 
     * Shows a messagebox containing a warning.
     * @param title The title of the message box.
     * @param message The message to display.
     * @param oktext The string to display as the confirmation button caption.
     */
    warning(title: string, message: string, oktext: string): MessageBox;

    /**
     * [old API - use DialogCreator]
     * 
     * Shows a messagebox containing an informational message.
     * @param title The title of the message box.
     * @param message The message to display.
     * @param oktext The string to display as the confirmation button caption.
     */
    info(title: string, message: string, oktext: string): MessageBox;

    /**
     * Shows a status box.
     * @param title The title of the message box.
     * @param message The message to display.
     */
    status(title: string, message: string): StandardWindow;

    /**
     * Shows a prompt.
     * @param title The title of the prompt.
     * @param message The message of the prompt.
     * @param def The default message to include.
     * @param callback The callback to use once the prompt is complete.
     * @param password Is a password prompt.
     */
    prompt(title: string, message: string, def: string, callback: Function, password?: boolean): StandardWindow;

    /**
     * Shows a confirmation prompt.
     * @param message The message to display.
     * @param callback The callback to call.
     * @param icon The icon to use.
     */
    confirm(message: string, callback: Function, icon?: string): MessageBox;

    /**
     * Shows a status box with an idle progress bar.
     * @param title The title of the message box.
     * @param message The message to display.
     */
    idleProgress(title: string, message: string): MessageBox;
}

/**
 * An object representing a dialog to allow the user to select (open) a file.
 */
interface OpenFileDialog {
    /**
     * Creates a file open dialog.
     * @param initialDirectory The initial directory to start in.
     * @param filter The file filter to use.
     * @param callback The callback to call once the dialog completes.
     */
    new(initialDirectory: string, filter: string[], callback: (path: string|null) => void);

    /** The current path. */
    currentPath: string;

    /** Whether the operation has completed. */
    completed: false;

    /** On complete callback */
    callback: (path: string|null) => void;

    /**
     * The file filter to use.
     * 
     * An example is `[".png", ".txt"]`.
     */
    filter: String[];

    /** Underlying dialog window. */
    dlg: StandardWindow;

    /** FileSystemView component */
    fsv: FSViewUIComponent;

    /** Pathbar element */
    pathBar: HTMLInputElement;

    /**
     * The dialog title.
     */
    title: String;

    /**
     * [internal] Creates the window for this dialog.
     */
    _createWindow(): Promise<void>;

    /**
     * [internal] Concludes the file selection.
     */
    _conclude(): Promise<void>;

    /**
     * [internal] Navigates the dialog to the specified path.
     * @param path The path to navigate to.
     * @param quiet Whether to be quiet.
     * @param addHistory Whether to populate history.
     */
    _navigate(path: String, quiet?: boolean, addHistory?: boolean): Promise<void>;

    /**
     * Shows the dialog.
     */
    show(): Promise<void>;
}

/**
 * An object representing a dialog to allow the user to save a file.
 */
interface SaveFileDialog extends OpenFileDialog {
    // Nothing special.
}

/**
 * Represents operation dialog options.
 */
interface OperationDialogOptions {
    /** The animation name to use. */
    animation?: "bin-empty"|"copy"|"copy-multi"|"delete"|"recycle";
    
    /** On cancel callback */
    oncancel?: (e?: { wndEvt: any })=>void;

    /** Whether to use an idle progress bar. */
    useIdleProgress?: boolean;

    /** Whether the operation can be cancelled. */
    canCancel?: boolean;

    /** Operation status text. */
    text: string;

    /** Dialog title. */
    title: string;
}

/**
 * Represents an operation dialog.
 */
interface OperationDialog {
    new(options?: OperationDialogOptions);

    /** Dialog parameters. */
    params: OperationDialogOptions;

    /** Underlying dialog window. */
    wnd: StandardWindow;

    /**
     * Sets the status text.
     * @param text The text to use.
     */
    setStatusText(text: string): void;

    /**
     * Sets the window progress.
     * @param percentage The percentage to set.
     */
    setProgress(percentage: number): void;

    /**
     * Closes the dialog.
     */
    close(): void;

    /**
     * Shows the dialog.
     */
    show(): void;

    /**
     * Waits for the dialog to complete.
     */
    wait(): Promise<void>;

    /**
     * Shows a copy operation dialog.
     * @param src An array of sources to copy.
     * @param dest The destination folder.
     */
    copy(src: string[], dest: string): Promise<void>;

    /**
     * Shows a move operation dialog.
     * @param src An array of sources to ,pve.
     * @param dest The destination folder.
     */
    move(src: string[], dest: string): Promise<void>;

    /**
     * Shows a recycling operation dialog.
     * @param src An array of sources to recycle.
     */
    recycle(src: string[]): Promise<void>;

    /**
     * Shows an item deletion dialog.
     * @param src An array of sources to delete.
     * @param type The type of deletion.
     */
    delete(src: string[], type?: "normal"|"trash"): Promise<void>;

    /**
     * [Not implemented]
     * Empties the recycle bin.
     */
    emptyBin(): Promise<void>;
}
// ======================== [/apis/ui/components.d.ts] =========================

/**
 * Base class for all UI components.
 * 
 * This class should be inherited.
 */
interface UIComponent extends EventEmitter {
    /**
     * The underlying HTML element.
     */
    uiComponent: Element;

    /**
     * Optional initialization code.
     */
    init(): void;

    /**
     * Returns the size of the component.
     * @returns {UISize}
     */
    getSize(): {
        w: Number;
        height: Number;
    };

    /**
     * Sets the size of the component.
     * @param w CSS prefixed width.
     * @param h CSS prefixed height.
     */
    setSize(w: number|string, h: number|string): void;

    /**
     * Returns the element for this UI component.
     */
    getElement(): Element;

    /**
     * Destroys the UI component.
     */
    destroy(): void;
}

/**
 * Represents FSView options.
 */
interface FSViewOptions {
    /**
     * Whether to show hidden files (files prefixed with a `.`).
     */
    showHiddenFiles: boolean,

    /**
     * Whether to allow navigation.
     */
    enableNavigation: boolean,

    /**
     * Whether to perform metadata lookups for a directory.
     */
    metaLookup: boolean,

    /**
     * Whether to allow thumbnails for image files.
     */
    iconPreviews: boolean,

    /**
     * Whether to use single click for item interaction.
     */
    singleClick: boolean,

    /**
     * The maximum allowed image size to use for thumbnails.
     */
    previewMaxSize: number,

    /**
     * The view mode.
     */
    viewMode: "icons"|"tile"|"details",

    /**
     * The intended view usage. "explorer" is the default.
     * Use "desktop" if you are intending to build a custom shell with a default icon view.
     * */
    alignMode: "explorer"|"desktop",

    /**
     * Icon alignment options. "align" specifies an ordered list of icons, "free" is the same as "align" with the exception to allow them to be freely moved.
     * */
    iconMovement: "align"|"free",

    /**
     * Stored icon positions.
     */
    storedIconPositions: [],

    /**
     * Special icons.
     */
    specialIcons: []
}

/**
 * File system view UI component.
 *
 * This component displays file system entries as icons.
 */
interface FSViewUIComponent extends UIComponent {
    /**
     * Creates a new File System View.
     * @param {String} fsPath The path to use for this view.
     */
    new(fsPath: string);

    /** Whether to navigate initially */
    initialNav: boolean;

    /** Current filesystem path. */
    fsPath: string;

    /** Currently selected icons */
    selectedIcons: HTMLElement[];

    /** Navigation history. */
    history: string[];

    /** Current history position. */
    historyPos: number;

    /** FS view options */
    options: FSViewOptions;

    /** FS Dropzone. */
    dropzone: DropZone;

    /** Select box listener. */
    selBoxListener: SelectBoxListener;

    /** Occurs when an item is double clicked */
    onitemdblclick: (element: HTMLElement)=>void;

    /** Occurs when an item is selected */
    onitemselected: (element: HTMLElement)=>void;

    /** Occurs on item drop */
    onicondrop: (element: HTMLElement)=>void;

    /** Occurs when a drag drop operation is completed. */
    ondropfinish: ()=>void;

    /** Conditional */
    onkeyrequest: ()=>boolean;

    /** On refresh needed */
    onrefreshneeded: ()=>void;

    /* Called after a clipboard action has been completed. */
    onclipboard: ()=>void;

    /** Readdir function */
    readdirFunc: (path: string)=>Promise<FSScanModeResult[]>;

    /**
     * [internal] Draw the watermark.
     */
    drawWatermark(): Promise<void>;

    /**
     * Performs a clipboard action.
     * @param action The clipboard action to perform.
     */
    performClipboard(action: "cut"|"copy"|"paste"): Promise<void>;

    /**
     * Resets the clipboard.
     */
    resetClipboard(): void;

    /**
     * Puts items on the clipboard.
     * @param items The items to put
     * @param action The action.
     */
    clipboardPut(items: string[], action: "cut"|"copy"): void;

    /**
     * Sets the view mode.
     * @param mode The view mode to use.
     */
    setViewMode(mode: "icons"|"tile"|"details"): void;

    /**
     * [unused]
     */
    init(): void;

    /**
     * Navigates to the specified path.
     * @param path The path to navigate to.
     * @param callback On navigation complete callback.
     * @param quiet Whether to play a sound upon navigation.
     * @param addHistory Whether to add the navigation to the navigation history.
     */
    navigate(path: string, callback?: (ents: string[]) => void, quiet?: boolean, addHistory?: boolean): Promise<void>;

    /**
     * Creates an icon.
     * @param label The label of the icon.
     * @param url The URL of the icon image.
     */
    mkIcon(label: string, url: string): HTMLDivElement;

    /**
     * Creates the rename box listener.
     * @param icon The icon to create the listener for.
     * @param onfinish On finish callback.
     */
    createRenameBoxListener(icon: HTMLDivElement, onfinish: (value?: string)=>void): void;

    /**
     * Deselects all icons.
     */
    deselectAllIcons(): void;

    /**
     * Selects an icon.
     * @param iconEl The icon element to target.
     * @param noDesel Do not deselect all previous icons.
     */
    selectIcon(iconEl: HTMLElement, noDesel?: boolean): void;

    /**
     * Sorts the icons.
     */
    sortIcons(): void;

    /**
     * Refreshes the view.
     * @param callback Callback.
     */
    refreshView(callback?: (ents: string[]) => void): Promise<void>;

    /**
     * Makes an icon dropzone.
     * @param iconElement The icon to make draggable.
     */
    _createIconFolderDropzone(iconElement: HTMLDivElement, ep: any): void;

    /**
     * Makes an icon draggable.
     * @param iconElement The icon to make draggable.
     */
    makeDraggable(iconElement: HTMLDivElement): void;

    /**
     * Go backwards in history.
     * @param navigate Whether to navigate. Default = true.
     */
    backwards(navigate?: boolean): string|undefined;

    /**
     * Go forwards in history.
     * @param navigate Whether to navigate. Default = true.
     */
    forwards(navigate?: boolean): string|undefined;

    /**
     * Go up a folder
     * @param navigate Whether to navigate. Default = true.
     */
    up(navigate?: boolean): string;

    /**
     * UI Create Directory.
     */
    uiCreateDirectory(cb: (result: boolean)=>void): void;

    /**
     * UI Create File.
     */
    uiCreateFile(cb: (result: boolean)=>void): void;
}

/**
 * Represents a UI control with tabbed pages.
 */
interface TabControl extends UIComponent {
    /**
     * Creates a new tab control.
     * 
     * Add pages to it using `addPage()`.
     */
    new();

    /**
     * [internal] Creates an activation zone.
     * @param btn The button to target.
     * @param onclick The action upon click.
     */
    _createActivationZone(btn: HTMLButtonElement, onclick: Function): void;

    /**
     * Opens a page.
     * @param {Number} id The ID of the page to open.
     */
    openPage(id: Number): void;

    /**
     * Adds a tab page.
     * @param title The title of the page to add.
     * @param ondraw Called on draw. Use this to set the contents.
     */
    addPage(title: String, ondraw: (e: HTMLElement) => void): Number;
}

/**
 * Represents a basic panel.
 */
interface Panel extends UIComponent {}

/**
 * Represents a container with a scrollable list of items.
 */
interface ListBox extends UIComponent {
    /**
     * Creates a new listbox.
     */
    new();

    /**
     * Called upon item selection.
     */
    onitemselected: (id: String) => void;

    /**
     * Called when the item is no longer selected.
     */
    onitemdeselected: (id: String) => void;

    /**
     * Adds an item to the listbox.
     * @param {String} label The label of the item.
     * @param {String} id The ID of the item.
     * @returns The underlying item element.
     */
    addItem(label: String, id?: string): HTMLDivElement;

    /**
     * Selects an item.
     * @param {String} id The ID of the item to select.
     * @returns Whether the item selection was successful.
     */
    selectItem(id: String): boolean;

    /**
     * Clears all items.
     */
    clear(): void;

    /**
     * [internal] Deselects all items.
     */
    _deselectAll(): void;
}

/**
 * The parameters used for group box creation.
 */
interface GroupBoxParams {
    /**
     * The group box title.
     */
    title: String;

    /**
     * The HTML body to use.
     */
    body: String;
}

/**
 * Represents a visibly named container with objects.
 */
interface GroupBox extends UIComponent {
    /**
     * Creates a new group box with the specified parameters.
     */
    new(params: GroupBoxParams);

    /**
     * Sets the HTML content of the container.
     * @param html The HTML content to use.
     */
    setBody(html: String): void;

    /**
     * Sets the title of the group box.
     * @param title The title to set.
     */
    setTitle(title: String): void;
}

/**
 * Represents an item (or root item) in a tree view UI component.
 */
interface TreeViewItem {
    /**
     * The item text.
     */
    label?: String;

    /**
     * The icon to use.
     */
    icon?: String;

    /**
     * Specifies whether this item should be opened by default if it were a root.
     */
    opened?: Boolean;

    /**
     * Subitems for item root.
     * 
     * If left empty (by default), this tree item is just an item instead of a root.
     */
    items?: TreeViewItem[];
}

/**
 * Represents a view with grouped items in a tree format.
 */
interface TreeView extends UIComponent {
    new(items: TreeViewItem[]);

    /**
     * [internal] Adds tree view items.
     * @param items The items to add.
     */
    _addItems(items: TreeViewItem[]): void;

    /**
     * Constructs a details element for the specified root item.
     * @param root The root item to create a details element for.
     */
    createDetails(root: TreeViewItem): HTMLDetailsElement;
}

/**
 * Represents a radio item in a radio box.
 */
interface RadioItem {
    /**
     * The item id.
     */
    id: String;

    /**
     * The item label.
     */
    label: String;

    onselect?: (e: {
        /**
         * The item radio input element.
         */
        element: HTMLInputElement,
        /**
         * The item id.
         */
        id: String
    }) => void;

    /**
     * Whether the item should be selected on creation.
     */
    selected?: Boolean;
}

/**
 * Represents a container with radio options.
 */
interface RadioBox extends UIComponent {
    /**
     * Creates a new radio box with the specified items.
     * @param items The items to use.
     */
    new(items: RadioItem[]);

    /**
     * [internal] Adds items to the radio box.
     * @param items The items to add.
     */
    _addItems(items: RadioItem[]): void;
}

/**
 * CheckBox UI component parameters.
 */
interface CheckBoxParams {
    /** Checkbox label. */
    label?: string;

    /** Whether the checkbox is checked. */
    checked?: boolean;

    /** On change callback */
    onchange?: (e?: { checked: boolean }) => void;

    /**
     * Whether to display as a block item.
     */
    displayAsBlock: boolean;
}

/**
 * Represents a checkbox.
 */
interface CheckBox extends UIComponent {
    new(params: CheckBoxParams);

    /** On change callback */
    onchange?: (e?: { checked: boolean }) => void;
}

/**
 * Represents toolbar options.
 */
interface ToolBarOptions {
    /** The icon size to use. */
    iconSize: number;

    /** Item defaults. */
    defaults: {
        /** Text position. */
        itemTextPosition: "bottom"|"top"|"left"|"right";
    },

    /** Whether to use compact mode. */
    compact: boolean;
}

/** Toolbar item properties */
interface ToolBarItemProps {
    /** Text position. */
    itemTextPosition?: "bottom"|"top"|"left"|"right";

    /** Item text. */
    text?: string;

    /** Item image URL. */
    imageUrl?: string;

    /** Whether the item is a dropdown item. */
    isDropdown?: boolean;

    /** The dropdown menu to use. */
    dropdownMenu?: ContextMenu;
    
    /** On item click event. */
    onclick?: ()=>void;

    /** Item name. */
    name?: string;
}

/**
 * Toolbar UI component.
 */
interface ToolBar extends UIComponent {
    new(options?: ToolBarOptions);

    /** Created ToolBar items. */
    createdItems: number;

    /**
     * Adds a separator.
     */
    addSeparator(): void;

    /**
     * Gets an item by id.
     */
    getItemById(id: number): HTMLDivElement;

    /**
     * Gets an item by name.
     * @param name The name of the item to lookup.
     */
    getItemByName(name: string): HTMLDivElement;

    /**
     * Gets an item.
     * @param nameOrId The name or ID of the item to get.
     */
    getItem(nameOrId: string|number): HTMLDivElement;

    /**
     * Sets whether an item is disabled.
     * @param ident The identifier of the item.
     * @param value The state to set.
     */
    setDisabled(ident: string|number, value: boolean): void;

    /**
     * Resets all item states.
     */
    resetItemStates(): void;

    /**
     * Adds an item to the toolbar.
     * @param options The options to use. 
     */
    addItem(options?: ToolBarItemProps): { el: HTMLDivElement, id: number };
}

/** Represents a graph stat box theme. */
interface GraphStatBoxTheme {
    /** The theme name. */
    name: string;

    /** Line color. */
    lineColor: string;

    /** The paper color. */
    paperColor: string;
}

/**
 * Represents graph stat box parameters.
 */
interface GraphStatBoxParams {
    /** Update interval */
    time: number;

    /** The graph stat box theme to use. */
    theme: GraphStatBoxTheme;

    /** Previous data to use. */
    previousData: [];

    /** On graph data. */
    ondata: (counter: number)=>number;

    /** On maximum value request. */
    onmaxval: ()=>number;

    /** Size specifiers. */
    size: {
        box_width: number;
        box_height: number;
        width: number;
        height: number;
    };

    /** The draw offset to use. */
    drawOffset: number;

    /** Whether to auto update the graph. */
    autoUpdate: number;

    /** Details */
    showDetails: {
        name: string;
        unit: string;
        enabled: boolean;
    }
}

/**
 * A UI component that displays a graph statistics box.
 */
interface GraphStatBox extends UIComponent {
    new(params?: GraphStatBoxParams);

    /** [internal] */
    _state: {
        /** Whether the graph has initialized. */
        init: boolean;
        proc: number;
        draw: (c: number)=>number;
    };

    /** The graph stat box parameters. */
    options: GraphStatBoxParams;

    /** Graph canvas element. */
    graph: HTMLCanvasElement;

    /** Details element. */
    detailsEl?: HTMLDivElement;

    /**
     * Initializes the graph.
     */
    init(): void;

    /**
     * Pause the continuous graph.
     */
    pause(): void;

    /**
     * Resumes the graph.
     */
    resume(): void;
    
    /**
     * Checks if the graph is paused.
     * @returns A boolean indicating whether the graph is paused or not.
     */
    isPaused(): boolean;

    /**
     * Manually invoke drawing.
     */
    draw(): void;

    /**
     * [internal] Ondata internal function. Used solely for the process hacker mode.
     */
    _ondata(val: number): void;

    /**
     * Destroys the graph.
     */
    destroy(): void;
}

/**
 * Represents explorer address bar properties.
 */
interface ExplorerAddressBarProps {
    /** Whether to use a compact toolbar. */
    compactToolbar: boolean;
}

/** Represents an explorer address bar. */
interface ExplorerAddressBar extends UIComponent {
    new(options?: ExplorerAddressBarProps);

    /** Navigate function callback. Necessary to make this component work. */
    navigate?: (path: string)=> string;

    /** Label element. */
    label: HTMLSpanElement;

    /** Address bar input element. */
    input: HTMLInputElement;

    /** Go button element. */
    go: HTMLButtonElement;

    /** On go function. */
    ongo(): void;

    /** Gets the current path. */
    getPath(): string;

    /** FS view. Must be set to make this component work. */
    fsv?: FSViewUIComponent;
}

/** Components namespace. */
interface ComponentsNS {
    /**
     * Base class for all UI components.
     * 
     * This class should be inherited.
     */
    UIComponent: {
        new(): UIComponent,
        prototype: UIComponent;
    };

    /**
     * Represents a UI control with tabbed pages.
     */
    TabControl: {
        /**
         * Creates a new tab control.
         * 
         * Add pages to it using `addPage()`.
         */
        new(): TabControl,
        prototype: TabControl
    };

    /**
     * Represents a basic panel.
     */
    Panel: {
        new(): Panel,
        prototype: Panel
    };

    /**
     * Represents a container with a scrollable list of items.
     */
    ListBox: {
        new(): ListBox,
        prototype: ListBox
    };

    /**
     * Represents a visibly named container with objects.
     */
    GroupBox: {
         /**
         * Creates a new group box with the specified parameters.
         */
        new(params: GroupBoxParams): GroupBox,
        prototype: GroupBox
    };

    /**
     * Represents a view with grouped items in a tree format.
     */
    TreeView: {
        new(items: TreeViewItem[]): TreeView,
        prototype: TreeView
    };

    /**
     * Represents a container with radio options.
     */
    RadioBox: {
        /**
         * Creates a new radio box with the specified items.
         * @param items The items to use.
         */
        new(items: RadioItem[]): RadioBox,
        prototype: RadioBox
    };

    /**
     * Represents a checkbox.
     */
    CheckBox: {
        new(params: CheckBoxParams): CheckBox,
        prototype: CheckBox;
    };

    /**
     * ToolBar UI component.
     */
    ToolBar: {
        new(options?: ToolBarOptions): ToolBar,
        prototype: ToolBar;
    };

    /**
     * A UI component that displays a graph statistics box.
     */
    GraphStatBox: {
        new(params?: GraphStatBoxParams): GraphStatBox,
        prototype: GraphStatBox;
    };

    /**
     * File system view UI component.
     *
     * This component displays file system entries as icons.
     */
    FSView: {
        /**
         * Creates a new File System View.
         * @param {String} fsPath The path to use for this view.
         */
        new(fsPath: string): FSViewUIComponent,
        prototype: FSViewUIComponent
    };

    /** Represents an explorer address bar. */
    ExplorerAddressBar: {
        new(options?: ExplorerAddressBarProps): ExplorerAddressBar,
        prototype: ExplorerAddressBar;
    };
}

// ======================== [/apis/ui/dlgcreator.d.ts] =========================
/**
 * Represents a dialog button.
 */
interface DialogButton {
    /** Button ID. */
    id: string;

    /** Button text */
    text: string;

    /** Button action */
    action: (e?: { btn: HTMLElement, dlg: Dialog })=>void | "$close";

    /** Whether this button is focused. */
    focus: boolean;
}

/**
 * Represents dialog paramters.
 */
interface DialogParams {
    /** The dialog title. */
    title?: string;

    /** The icon to use. */
    icon?: "warning"|"error"|"info"|"question"|string;

    /** Dialog text. */
    body?: string;

    /** Dialog buttons. */
    buttons?: DialogButton[];

    /** Dialog sounds. */
    sounds?: {
        error: string;
        warning: string;
        info: string;
        question: string;
    };

    events?: {
        onclose: (e?: { dlg: Dialog, e: any }) => void;
        onshown: (e?: { dlg: Dialog }) => void;
    };

    /** Max dialog width. */
    maxWidth?: number;

    /** Max dialog height. */
    maxHeight?: number;

    /** [internal] Whether to disable comments. */
    noComments?: boolean;
}

/**
 * Represents a dialog object.
 */
interface Dialog {
    new(props: DialogParams);

    /** The dialog creation parameters. */
    params: DialogParams;

    /** Dialog result. */
    result: {
        /** Selected button. */
        button?: string;
    }

    /** [internal] Do not use. */
    _resolveFn?: ()=>void;

    /** The underlying window. */
    wnd: StandardWindow;

    /** Whether the dialog is closing. */
    closing: boolean;

    /**
     * Closes the dialog.
     */
    close(): void;

    /**
     * Waits for dialog closure.
     */
    wait(): Promise<void>;

    /**
     * Shows the dialog.
     */
    show(): void;

    /**
     * Centers the dialog.
     */
    center(): void;

    /**
     * Returns the body.
     * @returns The body HTML container.
     */
    body(): HTMLElement;
}

/**
 * Progress dialog parameters.
 */
interface ProgressDialogParams extends DialogParams {
    /** The message to use. */
    message: string;

    /** The progress. */
    progress: "idle"|number;
}

/**
 * Represents a progress dialog.
 */
interface ProgressDialog extends Dialog {
    new(params: ProgressDialogParams);

    /**
     * Sets the dialog progress.
     * @param prog The progress to set.
     */
    setProgress(prog: "idle"|number): void;

    /**
     * Sets the progress message.
     * @param text The text to use.
     */
    setMessage(text: string): void;
}

/**
 * Fieldset key-value pair.
 */
interface FieldsetKVP {
    name: string,
    value: string;
}

/**
 * Fieldset object.
 */
interface FieldsetObject {
    /** Fieldset object caption. */
    caption?: string;

    /** Object type. */
    type: "textbox"|"spacer"|"text";

    /** Whether this object supports multiline. */
    multiline?: boolean;

    /** Field value. */
    value?: string;

    /** Whether the value is raw HTML. */
    raw?: boolean;

    /** Object style. */
    style?: string;

    /** Object classes. */
    classes?: string[];

    /** Object attributes. */
    attr?: FieldsetKVP[];

    /** Field name. */
    name?: string;
}

/**
 * Dialog creator API.
 */
interface DialogCreator {
    /**
     * Shows a progress dialog.
     * @param message The message to show.
     * @param properties Progress dialog properties. 
     */
    progress(message: string, properties?: ProgressDialogParams): ProgressDialog;

    /**
     * Creates a dialog containing a set of fields (useful for forms).
     * @param fieldObjects The field objects to use.
     * @param properties Additonal DlgCreator properties to pass.
     * @param callback Callback.
     */
    fieldset(fieldObjects: FieldsetObject[], properties?: DialogParams, callback?: (values?: FieldsetKVP[])=> void): Dialog;

    /**
     * Shows a simple alert box.
     * @param message The message to show.
     * @param properties Additonal DlgCreator properties to pass. 
     */
    alert(message: string, properties?: DialogParams): Dialog;

    /**
     * Show a confirmation prompt.
     * @param message The message for the prompt.
     * @param properties Additional DlgCreator options to append.
     * @param callback Callback upon decision complete.
     */
    confirm(message: string, properties?: DialogParams, callback?: (v: boolean)=>void): Dialog;

    /**
     * Shows a prompt.
     * @param message The prompt message.
     * @param properties Additional DlgCreator properties to append.
     * @param callback The callback to call upon prompt completion.
     */
    prompt(message: string, properties?: DialogParams, callback?: (value?: string)=> void): Dialog;

    /**
     * Creates a dialog.
     * @param {DialogParams} props The properties to use.
     */
    create(props: DialogParams): Dialog;

    /**
     * Represents a dialog object.
     */
    Dialog: {
        new(props?: DialogParams): Dialog,
        prototype: Dialog;
    };
}
// =========================== [/apis/ui/utils.d.ts] ============================
/** UI Utilities API */
interface UIUtilsAPI {
    /** CFX round. */
    cfxRound(u: number, i?: number, p?: number): number;

    /**
     * P3 connect UI dialog.
     */
    p3Connect(): Promise<boolean>;
}
// ============================= [/apis/wapp.d.ts] ==============================

/**
 * Application execution context.
 */
interface WApplicationExecCtx {
    launchCommand?: string;
}

/**
 * Represents a Windows 96 application instance.
 */
interface WApplicationInstance {
    new();

    /**
     * The app (process) ID.
     * 
     * Incremented when a new instance is created.
     * You can use this ID to kill your process.
     */
    readonly appId: Number;

    /**
     * The main application window.
     */
    readonly appWindow: StandardWindow;

    /**
     * A list containing all window objects owned by this application.
     */
    readonly windows: StandardWindow[];

    /**
     * IPC event queues.
     */
    readonly ipcEQs: string[];

    /**
     * Process title.
     */
    title: string;

    /**
     * Execution context.
     */
    execCtx: WApplicationExecCtx;

    /**
     * [internal] Whether the application is still running.
     */
    _running: Boolean;

    /**
     * [internal] Whether the application is in the process of shutting down.
     */
    _terminating: Boolean;

    /**
     * [internal] The exit result.
     */
    _appResult: any;

    /**
     * Called when the application is terminated.
     * 
     * @param result A user defined result.
     */
    onterminated?: (result: any) => void;

    /**
     * Sets a value as the app result.
     * @param v The value to use as a result.
     */
    setAppResult(v: any): void;

    /**
     * Terminates the application.
     */
    terminate(): void;

    /**
     * !! Do not override !!
     * Creates a new window for the specified application.
     * 
     * Set `isAppWindow` to false to create a sub window that closes when the main window closes.
     * @param params The parameters to use to create the window. 
     * @param isAppWindow Specifies whether this is an application window (the main window). Only one such window is allowed to exist.
     */
    createWindow(params: WindowParams, isAppWindow: boolean): StandardWindow;

    /**
     * The entry point to the application.
     * @param argv The arguments to pass to the application.
     */
    main(argv: string[]): Promise<any>;

    /**
     * Called when the application will be terminated.
     */
    ontermination(): void;

    /**
     * Unregisters all event queues.
     */
    unregisterAllEQs(): void;

    /**
     * Unregisters an Ipc EQ.
     * @param name The name of the queue to unregister.
     */
    unregisterIpcEQ(name: string): void;

    /**
     * Registers an IPC event queue.
     * @param name The name of the queue to create.
     */
    registerIpcEQ(name: string): EventEmitter;
}

/**
 * Represents a Windows 96 application class.
 * 
 * This class must be inherited to create an application, it's useless on its own.
 */
interface WApplication {
    /**
     * Creates a new application instance.
     */
    new(): WApplicationInstance;
    prototype: WApplicationInstance;

    /**
     * Kills the specified process.
     * @param appId The id of the process/application to kill.
     * @param force Specifies whether to force the operation.
     */
    kill(appId: number, force: boolean): Promise<void>;

    /**
     * Execute the specified application instance asynchronously.
     * @param appInstance The application instance to execute asynchronously.
     */
    execAsync(appInstance: WApplicationInstance, args: string[], executionContext?: WApplicationExecCtx): Promise<any>;
}

/**
 * Represents the system process manager, which is responsible for managing all WApplication instances.
 */
interface ProcessManager {
    /**
     * Gets all active image names.
     */
    getImageNames(): string[];

    /**
     * Gets a process from process ID.
     * @param id The process ID to search for.
     */
    getFromPid(id: number): WApplicationInstance | undefined;

    /**
     * Quits the specified process.
     * @param id The ID or name (title) of the process to quit.
     * @param force Whether to use force. Default is false.
     */
    quit(id: string|number, force?: boolean): Promise<void>;

    /**
     * Gets all running processes.
     * @returns The processes that are running.
     */
    getRunningProcesses(): WApplicationInstance[];
}

/**
 * Environment state API.
 */
interface StateAPI {
    /**
     * Active processes.
     */
    processes: WApplicationInstance[];

    /**
     * System process manager.
     */
    procMgr: ProcessManager;
}
// ======================= [/apis/internal/devdbg.d.ts] ========================

/**
 * WinLogon API.
 */
interface WinLogon {
    /**
     * Displays a logon UI.
     * @param callback Authentication callback.
     * @param allowCancel Whether the logon UI can be canceled.
     * @param altText Whether to use alt text.
     */
    displayLogonUI(callback: (v: boolean) => void, allowCancel?: boolean, altText?: boolean): Promise<void>;

    /**
     * Displays a logon UI asynchronously.
     */
    displayLogonUIAsync(allowCancel?: boolean, altText?: boolean): Promise<void>;
}

/**
 * [internal] Internal Debug API.
 */
interface InternalDebugAPI {
    /** Process registry. */
    processes: WApplicationInstance[];

    /** WinLogon */
    WinLogon: WinLogon;

    /**
     * Immersive DE (CTRL+SHIFT+K menu) API.
     */
    ImmersiveDesktopEnvironment: IMDEAPI;

    /**
     * [unused]
     */
    SdgfxTest: any;
}
// ============================ [/apis/shell.d.ts] =============================
/**
 * Immersive DE API.
 */
interface IMDEAPI {
    /**
     * Initialize the immersive desktop environment.
     */
    init(): Promise<void>;

    /**
     * Close all IMDE popups.
     */
    closeAllPopups(): void;
}

/**
 * Shell file API.
 */
interface ShellFileQueue {
    queue: {
        /**
         * Returns the file queue.
         */
        get(): string[];

        /**
         * Clears the shell file queue.
         */
        clear(): void;
    }

    /**
     * Enqueues an item.
     * @param item The item to enqueue.
     */
    enqueue(item: String): void;

    /**
     * Enqueues files in the shell file queue.
     * @param items The items to enqueue.
     */
    enqueueMany(items: string[]): void;

    /**
     * Sets the target file manipulation operation for the queue.
     * @param name The name of the operation to use.
     */
    setOperation(name: "copy"|"move"): void;

    /**
     * Removes broken/nonexistent paths in the queue.
     */
    sanitize(): void;

    /**
     * Resets the shell file handler.
     */
    reset(): void;
}

/**
 * Notify icon creation parameters.
 */
interface NotifyIconParams {
    /**
     * Onclick event.
     */
    onclick?: (e: { type: "context"|"normal", event: MouseEvent })=> void;
    
    /**
     * On double click event.
     */
    ondblclick?: (e: { event: MouseEvent })=> void;
    
    /**
     * [not implemented]
     */
    tooltip: string;

    /**
     * Icon URl.
     */
    iconUrl: string;
}

/**
 * An object representing a notification icon in the taskbar.
 */
interface NotifyIconInstance {
    /**
     * Onclick event.
     */
    onclick?: (e: { type: "context"|"normal", event: MouseEvent })=> void;
    
    /**
     * On double click event.
     */
    ondblclick?: (e: { event: MouseEvent })=> void;

    /**
     * Creation parameters.
     */
    params: NotifyIconParams;

    /**
     * The underlying HTML element for this icon.
     */
    notifyEl: HTMLDivElement;

    /**
     * Sets the icon url.
     * @param iconUrl The icon URL to set it to.
     */
    setIcon(iconUrl: String): void;

    /**
     * Hides this notification icon.
     */
    hide(): void;

    /**
     * Shows this notification icon.
     */
    show(): void;

    /**
     * Destroys the notification icon.
     */
    destroy(): void;
}

/**
 * The shell taskbar.
 */
interface ShellTaskbar {
    /**
     * Assigns an element the taskbar role.
     * @param el The element to use as the taskbar.
     **/
    assign(el: HTMLElement): void;

    /**
     * Creates an appbar for the specified window.
     * @param wnd The window to create an appbar for.
     */
    createWindowAppBar(wnd: StandardWindow): void;

    /**
     * Activates an appbar for the specified window.
     * @param winId The window id to activate the app bar for.
     * @param click Whether to trigger the click event.
     */
    activateAppBar(winId: string, click?: boolean): void;

    /**
     * Deactivates an appbar for the specified window.
     * @param winId The window id to use.
     */
    deactivateAppBar(winId: string): void;

    /**
     * Destroys an appbar.
     * @param winId The window id to use.
     */
    destroyAppBar(winId: string): void;

    /**
     * Registers a notification icon in the notification area of the taskbar.
     * @param iconObject The icon object to register.
     */
    registerNotifyIcon(iconObject: NotifyIconInstance): void;

    /**
     * Sets the visibility of the taskbar.
     * @param visible Whether to show it or not (default = true).
     */
    setVisibility(visible?: boolean): void;
}

/**
 * Windows 96 shell API.
 */
interface ShellAPI {
    /**
     * Creates a shortcut.
     * @param path The path to create the shortcut.
     * @param icon The icon name to use for the shortcut (URLs supported).
     * @param action The action to take.
     * @param showShortcutEmblem Whether to hide the shortcut emblem (default = false).
     */
    mkShortcut(path: string, icon: string, action: string, hideShortcutEmblem?: boolean): Promise<void>;

    /**
     * File queue API.
     */
    fileQueue: ShellFileQueue;

    /**
     * Taskbar API.
     */
    Taskbar: ShellTaskbar;

    /**
     * An object representing a notification icon in the taskbar.
     */
    NotifyIcon: {
        /**
         * Creates a new notification icon.
         * @param params Notify icon parameters to use.
         */
        new(params?: NotifyIconParams): NotifyIconInstance;
        prototype: NotifyIconInstance;
    };

    /**
     * Immersive Desktop Environment API.
     */
    imde: IMDEAPI;
}
// ======================= [/apis/internal/kernel.d.ts] ========================
/**
 * Kernel console instance.
 */
interface KConsoleInstance {
    /**
     * Prints a string onto the console.
     * @param text The string to print.
     */
    print(text: string): HTMLSpanElement;

    /**
     * Prints a string onto the console with styles.
     * @param text The string to print.
     * @param style The css styles to use.
     */
    print_styled(text: string, style: string): void;

    /**
     * Prints a string onto the console with styles.
     * @param text The string to print.
     * @param style The css styles to use.
     */
    println_styled(text: string, style: string): void;

    /**
     * Prints a string onto the console.
     * @param {String} text The string to print.
     */
    println(text: string): void;

    /**
     * Prints an error onto the console.
     * @param text The string to print.
     */
    error(text: string): void;

    /**
     * Prints a warning onto the console.
     * @param text The string to print.
     */
    warn(text: string): void;

    /**
     * Closes the console instance and destroys the container associated.
     */
    close(): Promise<void>;

    /**
     * Clears the console.
     */
    clear(): void;
}

/**
 * Kernel info API.
 */
interface KernelInfo {
    /** Kernel branch (e.g. stable) */
    branch: string;

    /** Kernel status. */
    status: "OFFICIAL"|"MODDED";

    /** Kernel name. */
    name: string;

    /** Main RootFS URL. */
    rootfsUrl: string;
}

interface KTypesAPI {
    /**
     * Kernel console class.
     */
    KConsole: {
        /**
         * Creates a write-only console terminal.
         * @param container The container element to apply the convga terminal to.
         */
        new(container: HTMLElement): KConsoleInstance;
        prototype: KConsoleInstance;
    }
}
// ============================= [/apis/sec.d.ts] ==============================
/**
 * Encryption result.
 */
interface EncryptionResult {
    /** The encrypted data. */
    data: ArrayBuffer;

    /** The initialization vector. */
    iv: Uint8Array;

    /** Whether the data is a string. */
    isStr: boolean;

    /** Whether its json. */
    isJSON: boolean;
}

/**
 * Cryptography provider API.
 */
interface CryptoProvider {
    /**
     * Simple digest function.
     *
     * Default hash function is SHA-256.
     * @param text The text to hash.
     * @param algorithm The algorithm to use. Default is "SHA-256".
     * @returns The hashed data.
     */
    simpleDigest(text: string, algorithm?: string): Promise<ArrayBuffer>;

    /**
     * Converts a buffer to hex string.
     * @param buffer The buffer to convert.
     * @returns The hex string.
     */
    buffer2hex(buffer: ArrayBuffer): string;

    /**
     * Converts a password to a Key Material.
     * Requires Crypto API.
     * @param password Password to use.
     */
    passwordToKM(password: string): Promise<CryptoKey>;

    /**
     * Derive key from KeyMaterial
     * @param keyMaterial Key Material to use.
     * @param salt The salt.
     */
    deriveFromKM(keyMaterial: CryptoKey, salt: any): Promise<CryptoKey>;

    /**
     * Encrypt using Key
     * @param key Key to use.
     * @param data Data to encrypt.
     */
    encrypt(key: CryptoKey, data: ArrayBuffer): Promise<EncryptionResult>;

    /**
     * Decrypt using Key
     * @param key Key to use.
     * @param data Data to decrypt.
     */
    decrypt(key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer>;
}

/**
 * Kernel security API.
 */
interface SecurityAPI {
    /** Cryptography provider. */
    cprovider: CryptoProvider;
}
// =========================== [/apis/sys/sys.d.ts] ============================

/**
 * An object representing the current Windows 96 OS release.
 */
interface OSRelease {
    /**
     * Gets the version string.
     */
    getVersionString(): string;

    /**
     * Get latest version.
     */
    getLatestVersion(): Promise<number>;

    /**
     * Get latest version as a string.
     */
    getLatestVersionString(): Promise<string>;

    /**
     * Get current build #.
     */
    getBuildId(): Promise<string>;

    /**
     * Get latest build #.
     */
    getLatestBuildId(): Promise<string>;

    /**
     * Gets the version number.
     */
    getVersion(): number;

    /**
     * Gets the release channel of the current build.
     */
    getReleaseChannel(): string;

    /**
     * Gets the build target.
     */
    getType(): "web"|"installer"|"bootable";

    /**
     * Returns the kernel build #, stored in rootfs.
     */
    getRootFSBuild(): Promise<number>;

    /**
     * Whether the current release is a legacy (v2) version of Windows 96.
     */
    isLegacyV2(): Promise<boolean>;
}

/**
 * An object representing the current system environment.
 * 
 * Environment variables and such may be defined here.
 */
interface SystemEnvironment {
    /**
     * Sets an environment variable.
     * @param key The key to set.
     * @param value The value to assign.
     */
    setEnv(key: string, value: string): void;

    /**
     * Gets the value of an environment variable key.
     * @param key The key to retrieve the value from.
     */
    getEnv(key: string): string;

    /**
     * Returns the environment keys;
     */
    envKeys: string[];
}

/**
 * System loader API.
 */
interface LoaderAPI {
    /**
     * Loads a text file from URL.
     * @param path The path of the text file to load.
     * @param cache Whether to cache this file (default = true).
     */
    loadTextAsync(path: string, cache?: boolean): Promise<string>;

    /**
     * Loads a JavaScript library.
     * @param url The URL of the library to load.
     */
    loadlibAsync(url: string): Promise<void>;

    /**
      * Loads a CSS file into the current session.
      * @param url The URL of the CSS file to load.
      */
    loadStyleAsync(url: string): Promise<void>;

    /**
      * Creates a style element of a local CSS file.
      * @param path The path of the CSS file to load.
      */
    createStyleFromPath(path: string): Promise<HTMLStyleElement>;
}

/**
 * WASM API.
 */
interface WASMAPI {
    /**
     * Loads a wasm file locally.
     * @param path The path of the WebAssembly file to load.
     * @param exposeStandardImports Whether to expose standard Windows 96 API imports for WASM. This is optional and set to `true` by default.
     */
    loadLocal(path: String, exposeStandardImports?: Boolean): Promise<WebAssembly.WebAssemblyInstantiatedSource>;

    /**
     * Executes a WASM binary.
     * @param path The path of the WebAssembly file to load.
     * @param suppressErrors Whether to suppress errors. This is optional and set to `false` by default.
     */
    execPrgm(path: String, suppressErrors?: Boolean): Promise<WebAssembly.ExportValue>;

    /** WASM utilities. */
    util: {
        /**
         * Converts a string constant to wasm.
         * @param str The string to convert.
         * @param stripComments Whether to strip comments. This is optional and set to `false` by default.
         */
        strconst2wat(str: string, stripComments?: boolean): String;
    };
}

/**
 * A class to read directory metadata.
 */
interface DirMetadataReader {
    /**
     * Constructs a dir metadata reader.
     * @param dirPath The directory path to read.
     */
    new(dirPath: String);

    /**
     * Metadata file path.
     */
    metaPath: String;

    /**
     * Properties retrieved from meta file.
     */
    properties: {
        background: string;
        icon: string;
        description: string;
        displayName: string;
        generateThumbnails: boolean;
    }
}

/**
 * Backup manager API.
 */
interface BackupManagerAPI {
    /**
     * Creates a backup and returns the `JSZip` instance.
     */
    makeBackup(): Promise<any>;
}

/**
 * OS Service parameters.
 */
interface OSServiceParams {
    /** Service ID. */
    id: string;

    /** Friendly service name. */
    friendlyName: string;

    /**
     * Whether to autostart the service.
     */
    autostart?: boolean;
}

/**
 * A class representing an OS service.
 * 
 * This class should be inherited.
 */
interface OSService {
    new(params: OSServiceParams);

    /** Service ID. */
    id: string;

    /** Friendly service name. */
    friendlyName: string;

    /**
     * Whether to autostart the service.
     */
    autostart?: boolean;

    /** Whether the service is running. */
    running: boolean;

    /**
     * Starts this service.
     */
    start(): Promise<void>;

    /**
     * Stops this service.
     */
    stop(): Promise<void>;
}

/**
 * Represents an OS service manager.
 */
interface ServiceManager {
    new();

    /** Registered services. */
    services: OSService[];

    /**
     * Finds a service by ID.
     * @param id The ID of the service to find.
     */
    find(id: string): OSService;

    /**
     * Registers a service.
     * @param svc The service to register.
     */
    register(svc: OSService): void;

    /**
     * Parses a service file.
     * @param path The path to the service file to parse.
     */
    parse(path: string): Promise<OSService>;

    /**
     * Starts a service.
     * @param service The service/service ID to start.
     * @param args Service arguments.
     */
    start(service: string | OSService, args: string[]): Promise<void>;

    /**
     * Stops a service.
     * @param service The service/service ID to start.
     * @param args Service arguments.
     */
    stop(service: string | OSService, args: string[]): Promise<void>;

    /**
     * Returns all registered services.
     * @returns The services.
     */
    getAll(): OSService[];
}

/**
 * Represents a device profile.
 */
interface DeviceProfile {
    /** Profile metadata. */
    meta: {
        /** Profile name. */
        name: string;
    };

    /** Profile preferences. */
    preferences: {
        /** Whether to open items via single click instead of double click. */
        single_click: false
    }
}

/**
 * Device profile manager.
 * 
 * Used to handle different device types (e.g. mobile, desktop, etc.).
 * */
interface DevProfileManager {
    /**
     * Loads a device profile.
     * @param path The path of the profile to load.
     */
    loadProfile(path: string): Promise<void>;

    /**
     * Gets the current device profile.
     */
    getProfile(): DeviceProfile;
}

/**
 * Represents bios rom data.
 */
interface BiosRom {
    boot_entries: {}   
}

/**
 * BIOS (setup) configuration manager object.
 */
interface BiosConfigManager {
    /** Default rom */
    defaultRom: BiosRom;

    /**
     * Gets the ROM.
     */
    get(): BiosRom;

    /**
     * Saves the ROM.
     * @param rom The rom to save.
     */
    save(rom: BiosRom): void;

    /**
     * Loads the default ROM.
     */
    loadDefaults(): void;

    /**
     * Checks if there is a BIOS configuration present.
     */
    has(): string | undefined;
}

/** Host features manager. */
interface HostFeaturesManager {
    /**
     * Gets all supported features of this system.
     * 
     * Valid features are: `IndexedDB`, `LocalStorage`, `WebAssembly`, `WebGL`.
     */
    getAll(): string[];

    /**
     * Checks if this system has a particular feature.
     * @param features The features to check for.
     */
    has(features: string[]): boolean;
}

/**
 * Manages system flags.
 */
interface SystemFlagsManager {
    /**
     * Check if a flag is enabled or not.
     *
     * @param flag The flag to check.
     * @returns The state of the flag.
     */
    has(flag: string): boolean;

    /**
     * Change a flag's state to be enabled
     * or disabled.
     *
     * @param flag The flag to modify.
     * @param enabled The state to change the flag to.
     */
    set(flag: string, enabled: boolean): void;

    /**
     * Clear all flags.
     */
    clear(): void;

    /**
     * Return an array containing all flag names;
     */
    getAll: string[];
}

/** WEX API */
interface WEXAPI {
    /**
     * Runs a WEX file from path.
     * @param {String} path The path to read.
     */
    runFile(path: string): Promise<number>;
}

/**
 * WEX terminal.
 */
interface WEXTerminal {
    /** Creates a new WEX terminal */
    new(prgmPath: string, onclose: ()=>void);

    /**
     * Prints some text.
     * @param text The text to print.
     */
    print(text: string): void;

    /**
     * Prints some text and a new line.
     * @param text The text to print.
     */
    println(text: string): void;

    /**
     * Prints an error.
     * @param text The text to print.
     */
    printErr(text: string): void;
}

/**
 * C API provider instance.
 */
interface CAPIProviderInstance {
    /** Target frame. */
    target: Window;

    /** Created windows. */
    windows: StandardWindow[];

    /**
     * Requests the creation of a terminal.
     */
    requestTerminal(): WEXTerminal;

    /**
     * Sets the process title.
     * @param title The title to set.
     */
    setProcessTitle(title: string): void;

    /**
     * [gui.c] -> MkWindow(WINDOW_STRUCT)
     * @param params The parameters to use.
     */
    createWindow(params: WindowParams): number;
}

/**
 * C API process.
 */
interface CAPIProcess {
    /** Process ID. */
    pid: number;

    /** Process title. */
    title: string;

    /** Associated CAPIProvider instance. */
    cls: CAPIProviderInstance;
}

/**
 * Windows 96 C API utilities.
 */
interface C_API {
    /** Process APIs. */
    proc: {
        /** Active C processes. */
        processes: CAPIProcess[],

        /**
         * Kills a process.
         * @param {Number} pid The process to kill.
         */
        kill(pid: number): void;
    },

    /**
     * C API provider.
     */
    CAPIProvider: {
        new(target: Window): CAPIProviderInstance;
        prototype: CAPIProviderInstance
    }
}

/**
 * The SAM database.
 */
interface SAMDB {
    /** Username */
    name: string;

    /** Password salt. */
    salt: string;

    /** Password algorithm. */
    alg: string;

    /** Password hash. */
    pwd: string;
}

/**
 * SAM API.
 */
interface SAMAPI {
    /**
     * Reads the SAM config.
     * @returns The SAM database, or null.
     * */
    readSAM(): Promise<SAMDB>;

    /**
     * Returns true if a password is set,
     * false if not.
     */
    requiresCredentials(): Promise<boolean>;

    /**
     * Removes the logon password.
     */
    disableCredentials(): Promise<void>;

    /**
     * Sets the logon username and password.
     * @param user The username to set.
     * @param passwd The password to set.
     */
    setCredentials(user: string, passwd: string): Promise<void>;

    /**
     * Verifies the given credentials with the
     * stored password hash.
     * 
     * @param user The user to verify.
     * @param passwd The password to verify.
     */
    verifyCredentials(user: string, passwd: string): Promise<boolean>;
}

/**
 * Represents an event log record (event).
 */
interface EventLogRecord {
    /** Message text. */
    mesage: string;

    /** Event source name. */
    source: string;

    /** Record severity. */
    severity: "info"|"error"|"warning"|"none";

    /** Record creation date. */
    date: Date;
}

/**
 * Represents an event log, which logs information, errors, and warnings.
 */
interface EventLogInstance {
    /**
     * Contains all recorded events.
     */
    events: EventLogRecord[];

    /** 
     * Event log limits.
     */
    limits: {
        /** Maximum number of events. */
        eventCount: number;
    }

    /**
     * Whether this event log is silenced.
     * 
     * Silenced event logs will not produce event records.
     */
    silenced: boolean;

    /**
     * Logs a new event.
     * @param message The message to use for this event.
     * @param source Event source.
     * @param severity The event severity. Default is "none".
     */
    log(message: string, source: string, severity?: "info"|"error"|"warning"|"none"): void;

    /**
     * Sets whether to silence the event log.
     * @param val The value.
     */
    setSilenced(val: boolean): void;
}

/**
 * System API.
 */
interface SystemAPI {
    /**
     * Opens a file.
     * @param path The path of the file to open.
     * @param boxedEnv Environment to pass to WRT box.
     * @returns A result from whatever application executed the file.
     */
    execFile(path: string, boxedEnv?: any): Promise<any>;

    /**
     * Executes a command.
     * @param cmd The command to execute.
     * @param argv The arguments to pass.
     * @param boxedEnv Environment for the app.
     * @param customPaths Custom path values for the call.
     * @returns App result.
     */
    execCmd(cmd: string, argv?: string[], boxedEnv?: [], customPaths?: string[]): Promise<any>;

    /**
     * An object representing the current Windows 96 OS release.
     */
    OSRelease: OSRelease;

    /**
     * An object representing the current system environment.
     * 
     * Environment variables and such may be defined here.
     */
    env: SystemEnvironment;

    /**
     * Reboots the system.
     * @param noUI Whether a closing UI should be shown.
     */
    reboot(noUI?: boolean): Promise<never>;

    /**
     * Shuts down the system.
     */
    shutdown(): void;

    /**
     * System registry namespace.
     * 
     * Its main purpose is to administer the registration of apps.
     */
    reg: RegNS;

    /**
     * System loader API.
     */
    loader: LoaderAPI;

    /**
     * Renders a BSOD (blue screen of death).
     * @param message The message to render. 
     */
    renderBSOD(message: string): Promise<void>;

    /**
     * Sets the kernel image.
     * @param path The path of the kernel image to use.
     */
    setKernImage(path: string): Promise<void>;

    /**
     * A class to read directory metadata.
     */
    DirMetadataReader: DirMetadataReader;

    /**
     * An object representing the Windows 96 package manager.
     */
    PkMgr: {
        /**
         * Creates a new Package Manager object.
         */
        new(): PackMan,
        prototype: PackMan
    };

    /**
     * API to manage system backups.
     */
    BackupManager: BackupManagerAPI;

    /**
     * A class representing an OS service.
     * 
     * This class should be inherited.
     */
    Service: {
        new(params: OSServiceParams): OSService;
        prototype: OSService;
    };

    /**
     * Represents an OS service manager.
     */
    ServiceManager: {
        new(): ServiceManager;
        prototype: ServiceManager;
    };

    /** OS services. */
    services: ServiceManager;

    /** Device profile manager. Used to handle different device types (e.g. mobile, desktop, etc.). */
    DevProfileManager: DevProfileManager;

    /** BIOS (setup) configuration manager. */
    biosConfig: BiosConfigManager;

    /** Host features manager. Use it to query if features are available (e.g. WebAssembly). */
    features: HostFeaturesManager;

    /**
     * Manages system flags.
     */
    flags: SystemFlagsManager;

    /**
     * Windows 96 eXecutable API (for C/C++ native) apps.
     */
    wex: WEXAPI;

    /**
     * Windows 96 C API utilities.
     */
    capi: C_API;

    /**
     * SAM API.
     */
    sam: SAMAPI;

    /**
     * Service Worker FS bridge utils.
     */
    swfsbr: {
        /**
         * Checks whether the service worker FS bridge is available.
         */
        isOnline(): boolean;
    };

    /**
     * Mobile device configuration manager.
     */
    MobileDeviceConfiguration: {
        /**
         * Checks whether mobile mode is enabled.
         */
        isMobileModeEnabled(): boolean;

        /**
         * Gets the mobile device type.
         */
        getDeviceType(): string;

        /**
         * Apply mobile device patches.
         */
        applyPatches(): Promise<void>;
    }

    /** System event log. */
    log: EventLogInstance;

    /**
     * Represents an event log, which logs information, errors, and warnings.
     */
    EventLog: {
        /**
         * Constructs a new event log.
         */
        new(): EventLogInstance;
        prototype: EventLogInstance;
    }

    /**
     * Contains current kernel information.
     */
    kInfo: KernelInfo;
}
// =========================== [/apis/sys/reg.d.ts] ============================
/**
 * Represents a shell app.
 */
interface ShellApp {
    /** The app name */
    name?: string;

    /** The app icon name. */
    icon?: string;

    /** Execution command name. */
    exec: string;

    /** Associated file types (e.g. `['.jpg', '.png']`). */
    assoc: string[];
}

/**
 * System registry namespace.
 * 
 * Its main purpose is to administer the registration of apps.
 */
interface RegNS {
    /**
     * @deprecated Do not use this API.
     * [restricted]
     * See function definition for `w96.app.register`.
     */
    registerApp(...args: any[]): void;

    /**
     * Check if an application exists.
     * @param name The name of the application.
     */
    appExists(name: string): boolean;

    /**
     * Returns an array of installed app names.
     */
    getInstalledApps(): string;

    /**
     * Deregisters an app.
     * @param name The name of the app.
     */
    deregisterApp(name: string): void;

    /**
     * Execute a named application.
     * @param name The name of the app to execute.
     * @param args Command line arguments.
     * @param executionContext An additional execution context to pass.
     */
    executeApp(name: string, args: string[], executionContext: any): Promise<any>;

    /**
     * Returns all applications which handle a particular file type.
     * @param path The path of the file to handle.
     */
    getFileHandlers(path: string): string[];

    /**
     * Returns the shell app registry.
     */
    getShellAppRegistry(): ShellApp[];
}
// ========================= [/apis/sys/packman.d.ts] ==========================

/**
 * A package manager logger.
 */
interface PkMgrLogger {
    /**
     * Logs some text.
     * @param text The text to log.
     */
    log(text: String): void;
}

/**
 * Represents a sources list object.
 */
interface PkMgrSourcesList {
    /**
     * A list of source URLs.
     */
    sources: String[];

    /**
     * How often the sources should refresh.
     */
    updateFrequency: Number;
}

/**
 * An object representing a package.
 */
interface Package {
    /**
     * The package name (id).
     */
    name: String;

    /**
     * The package display name.
     */
    friendlyName: String;

    /**
     * The package description.
     */
    description: String;

    /**
     * The package author.
     */
    author: String;

    /**
     * The package category.
     */
    category: String;

    /**
     * The package version.
     */
    version: Number;

    /**
     * Installed package size (in bytes).
     */
    installedSize: number;

    /**
     * Package download size (in bytes).
     */
    downloadSize: number;

    /**
     * An array containing what features are required for this application.
     */
    feature_requirements: ["wasm"|"indexeddb"];

    /**
     * Minimum OS version number.
     */
    min_os_version: Number;

    /**
     * Maximum OS version number.
     */
    max_os_version: Number;

    /**
     * Dependent package names.
     */
    depends: [];

    /**
     * Package icon files urls.
     */
    iconFiles: {
        "32x32": String,
        "16x16": String
    }

    /**
     * Package repository URL
     */
    repo: String;

    /**
     * Repository index.
     */
    repoIndex: Number;

    /**
     * The repository ID.
     */
    repoId: String;

    /** Readme file path. */
    readmeFile?: string;

    packageRoot: String;

    /**
     * Returns the specific package name.
     */
    getSpecificName(): String;
}

interface PackageRepository {
    /**
     * Repository display name.
     */
    name: String;

    /**
     * Repository maintainers string.
     */
    maintainers: String;

    /**
     * Repository ID.
     */
    id: String;

    /**
     * Repository index.
     */
    index: Number;

    /**
     * Repository URL.
     */
    repo: String;
}

/** On progress event params. */
interface OnProgressParams {
    /** Message. */ 
    message: String;

    /** Message type. */
    type: string;
}

/**
 * An object representing the Windows 96 package manager.
 */
interface PackMan {
    new();

    /**
     * The logger used to log messages.
     */
    logger: PkMgrLogger;

    /**
     * The parsed sources list to be used by the package manager.
     */
    srcConfig: PkMgrSourcesList;

    /**
     * The currently loaded package metadatas.
     */
    packageCache: Package[];

    /**
     * A cache containing all loaded repositories.
     */
    repoCache: PackageRepository[];

    /**
     * Path unpack mappings.
     */
    unpackPathMappings: {
        source: String,
        dest: String
    }[];

    /**
     * Executed on failure.
     */
    onfailure: (e: {
        code: String,
        e: Error
    })=>void;

    /**
     * Checks the filesystem for package manager.
     */
    checkFS(): Promise<void>;

    /**
     * Reads the sources file and returns whether it completed successfully.
     * @returns A value indicating whether the source reading has succeeded.
     */
    readSources(): Promise<boolean>;

    /**
     * Resolves a source from index.
     * @param index The index to use.
     */
    resolveSourceFromIndex(index: Number): PackageRepository;

    /**
     * Resolves a source index from id.
     * @param id The id.
     */
    getSourceIndexFromId(id: string): Number;

    /**
     * Gets a package by name.
     * @param packageName The package name.
     * @returns The package.
     */
    getPackage(packageName: String): Package;

    /**
     * Gets the install state for a package.
     * @param {String} packageName The package name of the package to query install state for.
     */
    getPackageInstallState(packageName: String): Promise<"NOT_INSTALLED"|"UPGRADEABLE"|"INSTALLED"|"BROKEN">;

    /**
     * Gets an array of all dependencies to be installed for a certain package name.
     * @returns The packages to install.
     */
    walkDependencies(pkgName: String): Promise<Package[]>;

    /**
     * Reloads the package cache.
     */
    reloadPackageCache(): Promise<void>;

    /**
     * Unpack content zip from package.
     * @param binData Zip data.
     * @param pkg Package.
     * @param onprogress On progress update.
     */
    unpackContentZip(binData: Uint8Array, pkg: Package, onprogress?: (params: OnProgressParams)=>void): Promise<void>;

    /**
     * Removes a package.
     * @param {Package} pkg The package to remove.
     * @param onprogress On progress event.
     */
    removePackage(pkg: Package, onprogress?: (params: OnProgressParams)=>void): Promise<void>;

    /**
     * Checks the required features of a package.
     * @param pkg The package to check for.
     * @returns Missing features.
     */
    checkFeatures(pkg: Package): Promise<string[]>;

    /**
     * Installs a package.
     * @param pkg The package to install.
     * @param  onprogress On progress event.
     */
    installPackage(pkg: Package, onprogress?: (params: OnProgressParams)=>void): Promise<void>;

    /**
     * Gets all packages by category.
     * @param {String} cat The category to filter with.
     * @returns {Package[]} The results.
     */
    getPackagesByCategory(cat: String): Package[];

    /**
     * [internal] Performs Package Manager checks.
     */
    performChecks(): Promise<void>;
}
// ========================== [/apis/util/util.d.ts] ===========================

/**
 * Size formatting options.
 */
interface SizeFmtOptions {
    /** Unit divisor. */
    divisor: number;
    
    /** Size precision. */
    precision: number;

    /** Stop size. */
    stopSize: number;
}

/**
 * Size formatting API.
 */
interface SizeFormatter {
    /** Size map containing units in order. */
    SIZE_MAP: string[];

    /**
     * Gets a size string from the specified data length.
     * Example: 2048 -> 2 KB
     * @param {Number} len The input length.
     * @param {*} opts Options.
     */
    getSizeStringFromLength(len: number, opts?: SizeFmtOptions): string;
}

/**
 * Represnts INI parsing options.
 */
interface INIParseOptions {
    escape: boolean;

    /** Whether to throw errors if they occur. */
    throwErrors: boolean;

    /**
     * Whether to infer types.
     */
    typeInference: boolean;

    /** How to handle recurring sections. Default is `merge`. */
    duplicateSectionMode: "merge"|"replace";
}

/**
 * Represents INI stringify options.
 */
interface INIStringifyOptions {
    escape: boolean;
}

/**
 * INI processing API.
 */
interface INIAPI {
    /**
     * Parses some INI configuration.
     * @param text The text to parse.
     * @param options The parsing options to use.
     */
    parse(text: string, options?: INIParseOptions): any;

    /**
     * Serializes a flat object to INI.
     * @param obj The object to serialize.
     * @param options The options to use.
     */
    stringify(obj: any, options?: INIStringifyOptions): string;

    /**
     * Represents an INI parsing error.
     */
    INIParsingError: {
        /**
         * Constructs a parsing error.
         * @param line The line at which the error occurred.
         * @param col The column at which the error occurred.
         * @param message The message to report
         */
        new(line: number, col: number, message: string): Error;
        prototype: Error;
    };
}

/**
 * Utilities API.
 */
interface UtilAPI {
    /**
     * CLI utilities.
     */
    cli: {
        /**
         * Represents a progress bar.
         */
        ProgressBar: {
            /**
             * Creates a new progress bar with the specified length, action, and terminal.
             */
            new(length: number, action: string, term: XTermInterface): ProgressBarInstance;
            prototype: ProgressBarInstance;
        }

        /**
         * Represents a console spinner.
         */
        Spinner: {
            new(action: string, term: XTermInterface): SpinnerInstance;
            prototype: SpinnerInstance;
        }
    },

    /**
     * [external] https://github.com/deecewan/browser-util-inspect
     * 
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param obj The object to print out.
     * @param opts Optional options object that alters the output.
     * @license MIT ( Joyent)
     */
    /* legacy: obj, showHidden, depth, colors*/
    inspect(obj: any, opts: any): any;

    /**
     * Request a console terminal window.
     * @param title Terminal window title.
     * @param icon Terminal window icon.
     * @param noCBX Whether to disable the controlbox. Default = false.
     * @returns XTermInterface
     */
    requestTerminal(title: string, icon: string, noCBX?: boolean): Promise<TermRequest>;

    /**
     * Returns whether the specified string is a URL.
     * @param input The string to check.
     */
    isURL(input: string): boolean;

    /**
     * Checks whether a string is a data URL.
     * @param input The data URL to check.
     */
    isDataURL(input: string): boolean;

    /**
     * Sideloads a zip to the system drive.
     * @param url The URL of the ZIP to sideload.
     */
    sideloadZip(url: string): Promise<void>;

    /**
     * Converts a blob to data URI.
     * @param blob The blob to convert.
     */
    blobToDataURI(blob: Blob): Promise<string>;

    /**
     * Converts a data URI to Blob.
     * @param uri The data URI to convert.
     */
    dataURItoBlob (uri: string): Promise<Blob>;

    /**
     * Generates a random number between `min` and `max`.
     * @param min The minimum value.
     * @param max The maximum value.
     */
    rand(min: number, max: number): number;

    /**
     * Promisified `setTimeout()`.
     * @param ms The number of seconds to timeout for.
     */
    wait(ms: number): Promise<void>;

    /**
     * Clamps a number within the specified range.
     * @param min The minimum value.
     * @param max The maxmimum value.
     * @param n The number to use.
     */
    clampNum(min: number, max: number, n: number): number;

    /**
     * Resolves a mimetype from file path.
     * @param path The path of the file to retrieve the mimetype of.
     */
    getMimetypeFromPath(path: string): string;

    /**
     * Resolves a mimetype from extension.
     * @param extension The extension of the file to resolve the mimetype for.
     */
    getMimetype(extension: string): string;

    /** UUID API. */
    uuid: {
        /**
         * UUIDv4 Function
         */
        generateV4(): string;
    }

    /**
     * Escapes HTML.
     * @param unsafe The HTML to escape.
     */
    escapeHtml(unsafe: string): string;

    /** DOM utilities */
    DomUtils: {
        /**
         * Creates a HTML element.
         * @param type The type of element.
         * @param classes The classes to add.
         */
        mkElement(type: string, classes?: string[]): HTMLElement;
    }

    /**
     * Argument parsing API.
     */
    argParser: {
        /**
         * Parse a command string.
         * @param input The argument string to parse.
         */
        parse(input: string): string[];

        /**
         * Strips the options from an argument array.
         * @param startIndex Where to start stripping.
         * @param a The argument array to use.
         * @param filter The filter to use.
         */
        stripOptions(startIndex: number, a: string[], filter: string[]): boolean;
    }

    /**
     * Size formatting API.
     */
    sizeFmt: SizeFormatter;

    /**
     * INI API.
     */
    INI: INIAPI;
}
// =========================== [/apis/util/cli.d.ts] ============================
/**
 * Progress bar instance.
 */
interface ProgressBarInstance {
    /** Action string */
    action: string;

    /** Underlying terminal. */
    term: XTermInterface;

    /** Progress bar length */
    length: number;

    /**
     * Progress bar text.
     */
    readonly text: string;

    /**
     * Sets progress.
     * @param n The progress to use.
     */
    setProgress(n: number): void;

    /**
     * Stops progress.
     * @param msg Stop message.
     * @param noLB Add line break? Default is false.
     */
    stop(msg: string, noLB?: boolean): void;
}

/**
 * Represents an instance of the `Spinner` class.
 */
interface SpinnerInstance {
    /** Action string. */
    action: string;

    /** The underlying terminal. */
    term: XTermInterface;

    /** Starts the spinner */
    start(): void;

    /**
     * Stop sthe spinner.
     * @param noLB Exclude line break? Default is false.
     */
    stop(noLB?: boolean): void;
}

/**
 * Terminal write options.
 */
interface TermWriteOpts {
    /** Whether to convert CRLF. */
    convertCRLF: boolean;

    /** Whether to escape ANSI codes. */
    escapeANSI: boolean;
}

/**
 * XTerm interfacing object.
 */
interface XTermInterface {
    /**
     * Creates a new XTI.
     * @param term Xterm terminal [external]
     * @param color Color [external]
     * @param wnd The window to use.
     */
    new(term: any, color: any, wnd: StandardWindow);

    /**
     * [external] XTerm terminal.
     */
    term: any;

    /**
     * [external] Color.
     */
    color: any;

    /**
     * Gets the last chars.
     */
    get lastChars(): string;

    /**
     * Has new line?
     */
    get hasNewLine(): boolean;

    /**
     * Prints text.
     * @param text The text to print.
     * @param opts The options to use.
     */
    write(text: string, opts?: TermWriteOpts): void;

    /**
     * Prints text (with newline).
     * @param text The text to print.
     * @param opts The options to use.
     */
    writeln(text: string, opts?: TermWriteOpts): void;

    /**
     * Prints text.
     * @param text The text to print.
     * @param opts The options to use.
     */
    print(text: string, opts?: TermWriteOpts): void;

    /**
     * Prints text (with newline).
     * @param text The text to print.
     * @param opts The options to use.
     */
    println(text: string, opts?: TermWriteOpts): void;

    /**
     * Prints text (escaped, with newline).
     * @param text The text to print.
     * @param opts The options to use.
     */
    printlnEscaped(text: string, opts?: TermWriteOpts): void;

    /**
     * Prints an error.
     * @param text The text to print.
     * @param opts The options to use.
     */
    printError(text: string, opts?: TermWriteOpts): void;

    /**
     * Creates a prompt.
     * @param question The question to ask.
     * @param allowCtrlC Whether to allow CTRL+C to break out of it. Default = false.
     */
    prompt(question: string, allowCtrlC?: boolean): Promise<void>;

    /**
     * Pauses the terminal.
     */
    pause(): Promise<void>;

    /**
     * Clears the terminal
     */
    clear(): void;

    /**
     * Escapes ANSI text.
     * @param text The text to escape.
     */
    escapeANSI(text: string): string;
    
    /**
     * [internal]
     */
    onData(): void;
}

/**
 * Requested terminal object.
 */
interface TermRequest {
    /**
     * Stops the console host.
     */
    stopHost(): void;

    /**
     * The terminal object.
     */
    terminal: XTermInterface;
}
// =========================== [/apis/net/net.d.ts] ============================

/**
 * Cross iframe API.
 */
interface CrossIFRAPI {
    /**
     * Register the `postMessage()` handler.
     */
    register(): void;

    /**
     * Registers basic events.
     */
    registerBasicEvents(): void;

    /**
     * Trusts a URL.
     * @param {String} url The URL to trust.
     */
    trust(url: String): void;

    events: EventEmitter;
}

/**
 * Networking API.
 */
interface NetAPI {
    /**
     * Cross iframe API.
     */
    crossifr: CrossIFRAPI;

    /**
     * Networking protocols.
     */
    protocols: {
        P3: {
            new(params: P3ConnectionParams): P3ConnectionInstance;
            prototype: P3ConnectionInstance;
        },
        PPP2: _ExternalSymbol,
        IP: _NotImplementedSymbol
    },

    netfs: _NotImplementedSymbol
}
// ============================ [/apis/net/p3.d.ts] =============================
/**
 * P3 event emitter.
 */
interface P3EventEmitter {
    _cb: {};

    on(event: string, callback: Function): void;
    removeEventListener(event: string, callback: Function): void;
    emit(event: string, data: any): void;
} 

/**
 * P3 connection parameters.
 */
interface P3ConnectionParams {
    /** The relay server to use. */
    relayServer?: string;

    /** Whether to connect automatically. */
    autoconnect?: boolean;

    /** P3 secret. */
    secret?: string;
}

/**
 * P3 server options.
 */
interface P3ServerOptions {
    /** Heartbeat interval */
    heartbeat: number;

    /** The port to use. */
    port: number;
}

/**
 * P3 server.
 */
interface P3Server extends P3EventEmitter {
    new(port: number, options: P3ServerOptions);

    /** Active connections */
    connections: any;

    _timeoutInterval: number;

    /**
     * Checks if the specified peer exists.
     * @param id The ID of the peer to check for.
     */
    peerExists(id: string): boolean;

    /**
     * Send some data.
     * @param args The data to send.
     */
    send(...args: any): Promise<void>;

    /**
     * Binds to a p3 instance.
     */
    bind(p3: P3ConnectionInstance): void;

    /**
     * Opens the server.
     */
    open(): void;

    /**
     * Closes the server.
     */
    close(): void;

    /**
     * Unbinds the server.
     */
    unbind(): void;
}

/**
 * P3 socket type.
 */
interface P3Socket {
    new(address: string, _server?: P3Server, _isServerClient?: boolean);

    /** Whether the socket is connected. */
    connected: boolean;

    /** Whether the socket is closed. */
    closed: boolean;

    /** The remote address */
    remoteAddress: string;

    /** P3 server. */
    _server: P3Server;

    /** Whether this socket is a server client. */
    _isServerClient: boolean;

    /** Heartbeat interval. */
    _heartbeatInterval: number;

    /** Heartbeat. */
    heartbeat: number;

    /** Peer ID. */
    peerID: string;
    
    /** Response port. */
    responsePort: number;

    /** nonce */
    nonce: number;

    /**
     * Send some data.
     * @param dat The data to send.
     */
    send(dat: any): Promise<void>;

    /**
     * Attempts a connection.
     */
    connect(): Promise<void>;

    /**
     * Disconnect.
     * @param sendDisconnectPacket Whether to send a disconnect packet.
     * @param reason The reason for disconnecting.
     */
    disconnect(sendDisconnectPacket?: boolean, reason?: { message: string }): Promise<void>;
}

/**
 * Represents a P3 connection.
 */
interface P3ConnectionInstance extends P3EventEmitter {
    /** P3 connection parameters */
    _params: P3ConnectionParams;

    /** Connection attempts */
    attempts: number;

    /** Whether P3 is connecting. */
    connecting: boolean;

    /** Connected state. */
    connected: boolean;

    /** Error state. */
    error: boolean;

    /** Ports */
    ports: any;

    /** Active connections */
    connections: P3Socket[];
}
// =========================== [/apis/net/ppp2.d.ts] ============================
// not implemented - work in progress

interface PPP2Client extends _ExternalSymbol {}
// ============================ [/apis/debug.d.ts] =============================
/**
 * Debugging API.
 */
interface DebugAPI {
    /** Performance monitoring APIs */
    perf: {
        /**
         * Creates a debug DOM element showing the current framerate.
         */
        showDOMFps(): void;
    };

    /**
     * Checks for a condition and throws an error upon failure.
     * @param condition The condition to check for.
     * @param data The assertion data.
     */
    assert(condition: boolean, data: any): void;

    /**
     * Debug FS write UI.
     * @param path The path to write to.
     */
    debugWriteUI(path: string): void;
}
// ============================= [/apis/ipc.d.ts] ==============================
/**
 * IPC API.
 */
interface IPCAPI {
    /**
     * Creates an IPC event queue.
     * @param name The name of the queue to create.
     */
    createIpcEQ(name: string): EventEmitter;

    /**
     * Finds an IPC event queue.
     * @param name The name of the queue.
     * @returns 
     */
    findIpcEQ(name: string): EventEmitter;

    /**
     * Destroys an IPC event queue.
     * @param name The name of the queue.
     */
    destroyIpcEQ(name: string): void;
}
// ============================= [/apis/wrt.d.ts] ==============================
/** Requirement check parameters. */
interface ReqCheckParams {
    /** Enable UI mode (shows graphical errors). */
    ui: boolean;
}

interface WRTIncludeOptions {
    /**
     * Whether to ignore JS files as modules.
     * 
     * When a file is ignored, its simply read as a text string.
     */
    ignoreJS: boolean;
}

/**
 * WRT Run Context.
 */
interface WRTRunContext {
    /**
     * System requirements checking function
     * @param features The features to check for.
     * @param options The options to set.
     */
    require_check(features: string[], options: ReqCheckParams): Promise<boolean>;

    /** Current working directory. */
    cwd: string;

    /** Script directory .*/
    scriptDir: string;

    /** Module path. */
    modulePath: string;

    /** Target environment type. */
    envType: "normal"|"terminal"|"kernel"|"other";

    /** WRT Box environment. */
    boxedEnv: {}

    /** Launch command used. */
    launchCommand: string;

    /** Cached WRT modules. */
    cachedModules: {}

    /** Include helper function. Added by WRT automatically. */
    include(path: string, opts?: WRTIncludeOptions): Promise<any>;
}

/**
 * Represents a WRT module.
 */
interface WRTModule {
    /** The library path. */
    libPath: string;

    /** The module name. */
    moduleName: string;

    /** The module version. */
    version: string;
}

/**
 * Windows 96 Runtime (WRT) API.
 */
interface WRTAPI {
    /**
     * Executes WRT code.
     * @param code The code to execute.
     * @param params The parameters to use.
     */
    run(code: string, params: WRTRunContext): Promise<any>;

    /**
     * Executes WRT code from a file.
     * @param file The file to execute.
     * @param params The parameters to use.
     */
    runFile(code: string, params: WRTRunContext): Promise<any>;

    /**
     * Resolves a global module.
     * @param name The name of the module to resolve.
     */
    resolveModule(name: string): Promise<WRTModule>;
}
// ============================= [/apis/scm.d.ts] ==============================
/**
 * Represents an SCM index.
 */
interface SCMIndex {
    /** The description of the index. */
    description: string;

    /** Index ID. */
    id: string;

    /** Index name. */
    name: string;

    /** Whether the index is a pseudo-index. */
    pseudo: boolean;
}

/**
 * Represents an SCM item.
 */
interface SCMItem {
    /** Item type. */
    type: "root"|"key"|"value";

    /** Item name. */
    name: string;
}

/**
 * System Configuration Manager (SCM) API.
 */
interface SCMAPI {
    /**
     * [system] Loads all SCM configuration.
     * @param scmPathOverride SCM root directory path on the filesystem.
     */
    loadAll(scmPathOverride?: string): Promise<void>;

    /**
     * Creates a root.
     * @param name The name of the root to create.
     * @param description The description of this root.
     */
    createRoot(name: string, description?: string): void;

    /**
     * Flushes the current sys config to disk.
     */
    syncAll(): Promise<void>;

    /**
     * Synchronizes the specified root.
     * @param name The name of the root to sync.
     */
    syncRoot(name: string): Promise<void>;

    /**
     * Returns the index for the specified root.
     * @param name The name of the root to find the index for.
     */
    getIndex(name: string): SCMIndex;

    /**
     * Gets an object at the specified path.
     * @param path The path of the object to retrieve.
     */
    get(path: string): any;

    /**
     * Sets an object at the specified path.
     * @param path The path of the item to set.
     * @param value The value to set.
     */
    set(path: string, value: string): void; 

    /**
     * Sets an object at the specified path and immediately synchronizes the change.
     * @param path The path of the item to set.
     * @param value The value to set.
     */
    setAndSync(path: string, value: string): Promise<void>;

    /**
     * Removes an object.
     * @param path The path to remove the object from.
     */
    remove(path: string): boolean | void;

    /**
     * Removes an object.
     * @param path The path to remove the object from.
     */
    removeAndSync(path: string): Promise<boolean | void>;

    /**
     * Lists entries in the specified path.
     * @param path The path to use.
     */
    ls(path: string): SCMItem[];

    /** SCM storage path. */
    scmPath: string;
}
// =============================== [/index.d.ts] ================================

/**
 * The main Windows 96 API namespace.
 */
declare namespace w96 {
    /**
     * [internal] Windows 96 kernel entry point.
     */
    function main(): Promise<void>;

    /**
     * The Windows 96 file system API.
     */
    const FS: FS;

    /**
     * FS utilities API.
     */
    const FSUtil: FSUtil;

    /**
     * FS features enum.
     */
    const FSFeatures: {
        /** Read only file system. */
        readOnly: "read-only",

        /** Remote (non local) file system. */
        remote: "remote",

        /** Hidden file system. Does not show in explorer. */
        hidden: "hidden"
    }

    /**
     * Mutex API.
     */
    const mutex: MutexAPI;

    /**
     * Application API.
     */
    const app: AppAPI;

    /**
     * FS types namespace.
     */
    const fstype: FSType;

    /**
     * Window System API.
     */
    const WindowSystem: WindowSystem;

    /**
     * Represents window creation parameters.
     * 
     * All parameters are optional and have default settings.
     */
    const WindowParams: WindowParams;

    /**
     * Represents a window object.
     */
    const StandardWindow: StandardWindow;

    /**
     * User interface API.
     */
    const ui: UIAPI;

    /**
     * Represents a Windows 96 application.
     * 
     * This class must be inherited to create an application, it's useless on its own.
     */
    const WApplication: WApplication;

    /** [internal] Internal debug API. */
    const __debug: InternalDebugAPI;

    /**
     * Environment state API.
     */
    const state: StateAPI;

    /**
     * Kernel types API.
     */
    const ktypes: KTypesAPI;

    /**
     * Security API.
     */
    const sec: SecurityAPI;

    /**
     * System API.
     */
    const sys: SystemAPI;

    /**
     * Windows 96 shell API.
     */
    const shell: ShellAPI;

    /**
     * Utilities API.
     */
    const util: UtilAPI;

    /**
     * Networking API.
     */
    const net: NetAPI;

    /**
     * Debugging API.
     */
    const debug: DebugAPI;

    /** [unused] */
    const run: {};

    /**
     * IPC API.
     */
    const ipc: IPCAPI;

    /** 
     * Working memory.
     * 
     * Can be used for shared memory access by applications.
     * Applications should always clean their wmem resources!
     * */
    const wmem: {
        clockInt: 0;
        eCachedMetadata: {}
    };

    /**
     * Windows 96 Runtime (WRT) API.
     */
    const WRT: WRTAPI;

    /**
     * [external] js-yaml API
     * 
     * https://www.npmjs.com/package/js-yaml
     */
    const yaml: _ExternalSymbol;

    /**
     * Opens an URL.
     * @param url The URL to open.
     */
    function urlopen(url: string): Promise<void>;

    /**
     * Whether Windows 96 is running in recovery mode.
     */
    const isRecovery: boolean;

    /**
     * System Configuration Manager (SCM) API.
     */
    const sysConf: SCMAPI;

    /**
     * @returns Returns the Windows 96 about message.
     */
    function toString(): string;
}

/**
 * Represents an event emitter.
 * */
declare const EventEmitter: {
    /**
     * Creates a new event emitter.
     */
    new(): EventEmitter,
    prototype: EventEmitter;
};
